<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Devinor&#39;s Blog</title>
  
  <subtitle>Diversity  is  essential  to  happiness</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-09T04:18:13.665Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>devinor Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ros系统catkin文件</title>
    <link href="http://yoursite.com/2018/11/07/ros%E7%B3%BB%E7%BB%9Fcatkin%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/11/07/ros系统catkin文件/</id>
    <published>2018-11-07T05:02:23.000Z</published>
    <updated>2018-11-09T04:18:13.665Z</updated>
    
    <content type="html"><![CDATA[<p>catkin   是用来编译ros程序的<br>catkin 工作空间就是一个文件夹<br>组织和管理功能包的文件<br>用catkin工具编译</p><p>各种ros代码放在catkin workpace 文件夹中<br>如何:创建一个catkin的文件空间<br>指令:catkin_make   帮助我们初始化工作空间<br><a id="more"></a><br>$mkdir ~p ~/catkin_ws/src<br>$cd ~/catkin_ws/<br>$catkin_make<br>其实catkin_make的主要功能是编译</p><p>编译<br>$cd -/catkin_ws  #回到工作空间<br>$catkin_make<br>$source -/catkin_ws/devel/setup.bash</p><p>#编译完成之后要source刷新环境</p><p>注意:<br>catkin_make 之前一定要回到catkin workspace<br>catkin_make 之后一定要devel/setup.bash这句话是把刚刚编译的worksapce 刷新到环境里面</p><p>catkin workspace 里的<br>src文件 package源代码<br> build文件夹  cmake&amp; catkin 缓存文件和中间文件<br>devel文件夹: 生成的目标文件  包括 1.头文件 2.动态链接库 3.静态链接库 4.可执行文件<br>bulid 和devel 初学者不用掌握</p><p>注意::ros build 是旧的版本  看到资料直接忽略</p><p>src里面到底有什么<br>src 里面有许多package<br>package 是catkin编译的基本单元<br>catkin的编译对象就是一个又一个package</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;catkin   是用来编译ros程序的&lt;br&gt;catkin 工作空间就是一个文件夹&lt;br&gt;组织和管理功能包的文件&lt;br&gt;用catkin工具编译&lt;/p&gt;
&lt;p&gt;各种ros代码放在catkin workpace 文件夹中&lt;br&gt;如何:创建一个catkin的文件空间&lt;br&gt;指令:catkin_make   帮助我们初始化工作空间&lt;br&gt;
    
    </summary>
    
      <category term="ROS" scheme="http://yoursite.com/categories/ROS/"/>
    
    
      <category term="ROS" scheme="http://yoursite.com/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>网络通信协议(3)</title>
    <link href="http://yoursite.com/2018/11/07/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE3/"/>
    <id>http://yoursite.com/2018/11/07/网络通信协议3/</id>
    <published>2018-11-07T04:21:57.000Z</published>
    <updated>2018-11-09T04:10:19.755Z</updated>
    
    <content type="html"><![CDATA[<p>应用层<br>&emsp;&emsp;由于互联网是开放的架构, 数据来源是五花八门.所以事先必须规定一些格式,否则根本没有办法解读.<br>&emsp;&emsp;现在讲的应用层就是规定应用程序的数据格式.<br>&emsp;&emsp;举个例子, TCP协议可以为各式各样的程序传递数据, 比如EMAIL,www,FTP等等, 那么必须有不同的协议规定电子邮件, 网页, FTP的数据格式.这些应用程序的协议就构成了一个应用层, 这就是我们说的五层协议里面最高的一层, 是面对用户的.</p><p>他的数据就放在TCP协议的data部分,所以以太网数据包就会变成以下的样子.<br>Ethernet head | IP head |TCP head| –Application Layer data–<br>–|–|–|–|<br><br><br><br><br><img src="https://i.imgur.com/46b9CAd.png" alt="Imgur"><br><a id="more"></a><br>&emsp;&emsp;  在这幅图中, 有4台主机.1和2处于一个子网,3和4处于同一子网.<br>&emsp; &emsp; 如果1给4发送数据包.然后4告诉1, 收到了数据包.这样就可以实现两台计算机之间的通讯.<br>&emsp; &emsp; 而发送这个数据包就必须需要两个地址. MAC地址和IP地址, 有了这两个地址之后, 数据包才能够准确的送到接受者的手中.<br>&emsp; &emsp; 但是MAC地址是有局限的, 如果两台主机不在同一子网, 就没有办法知道彼此的MAC地址.<br><br></p><p>&emsp;&emsp;  所以出现了网关(gateway), 它实现转发的功能. 主机1给主机4发送数据包.他先判断主机4是否处于同一子网.如果不是, 主机1把数据包发给他的网关(A).<br>&emsp; &emsp; 这网关通过路由协议, 发现了主机4处于另一个网关内(B). A网关把数据发送给了B网关, B网关又把数据转发给了主机4.</p><p>&emsp; &emsp; 主机1想要把数据发送给A网关, 需要知道A网关的MAC地址.<br>&emsp; &emsp; 所以数据包的目标地址实际上分为两种情况.<br>场景|数据包地址<br>–|–<br>目标主机同一子网|对方的MAC地址,对方的IP地址<br>目标主机非同一子网|网关的MAC地址,对方的IP地址<br><br></p><p>我们在windows中连接网络,可能会看到静态IP和动态IP的选项<br><img src="https://i.imgur.com/sMXDp9F.png" alt="Imgur"></p><p>我们给电脑插上网线开机之后,不能立刻上网.我们必须要给电脑</p><ul><li>设置本机IP</li><li>设置子网掩码</li><li>设置网关的IP地址</li><li>设置DNS的IP地址</li></ul><p>静态IP<br>&emsp; 首先它设置比较专业<br>&emsp; 其次设置静态IP后这个IP不能被其他计算机使用处于这两点, 大部分用户都是使用动态IP地址上网.</p><p>动态IP<br>&emsp; 所谓的动态IP就是指计算机开机以后会自动分配一个ip地址, 这个IP地址不会被别人设定.</p><p>动态IP使用的协议是DHCP协议</p><p>&emsp;&emsp;  这个协议规定了,在每一个子网中, 有一台计算机作为DHCP服务器.它专门去负责这个网络内的所有IP地址的自动分配.<br>&emsp; &emsp; 所有新的计算机加入这个网络之后,必须向DHCP服务器发送一个DHCP请求数据包.以此来申请IP地址和相关的网络参数.</p><p>&emsp; &emsp; 之前提到,两个主机在同一子网时,必须知道对方的MAC地址IP地址,才能发送数据包.</p><p>&emsp; &emsp;<br>但是问题来了<br>新加入的主机不知道这两个地址.<br><br></p><p>DHCP协议做了一些比较巧妙的设定,首先它是应用层的协议,建立在UDP协议之上.<br>所以数据包是这样的</p><table><thead><tr><th>Ethernet head</th><th>IP head</th><th>UDP head</th><th>DHCP data</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>&emsp; &emsp; 最前面的Ethernet head设置发出方,比如本机的MAC地和接受方DHCP服务器的MAC地址.</p><p>&emsp; &emsp; 发射方的MAC地址就是本机网卡的MAC地址,DHCP服务器的MAC地址是不知道的.</p><p>&emsp; &emsp; 这个时候就会填入广播的地址,有一个默认的6组16进制数组成. FF:FF:FF:FF:FF:FF</p><p>&emsp; &emsp; 后面的IP head 设置了发出方的IP地址和接受方的IP地址.对于两个主机而言,他们本机都不知道.于是发出方的IP设为0.0.0.0,接收方的IP设为255.255.255.255.</p><p>&emsp; &emsp; 最后的UDP head设置发出方的端口和接受方的端口.这部分是由DHCP协议规定好的,发出方是68端口,接受方式67端口.</p><p>&emsp; &emsp; 数据包构造完成之后就可以发送了.以太网是以广播发送的,在同一子网内的每一台主机都会收到这个包.因为接收方的地址是FF:FF:FF:FF:FF:FF所以看不出来是发给谁的.收到这个包的主机会分析这个包的IP地址,确定是不是发给自己的.之前讲ARP协议的时候,已经有接触.</p><p>&emsp; &emsp; 当看到发出方的IP地址是0.0.0.0,接收方IP地址是255.255.255.255.于是DHCP服务器就知道这个包是发给我的.其他主机就会丢弃这个包.</p><p>&emsp; &emsp; 接下来DHCP服务器会读出这个包的数据内容,然后分配好一个IP地址,发送回去一个DHCP响应数据包.</p><p>&emsp; &emsp; DHCP响应数据包.它的格式和DHCP数据包类似.分配给请求方的IP地址和其他网络参数都会包含在data这部分.新加入的主机就知道了自己的IP地址,子网掩码,网关地址. 有了这个之后就可以上网冲浪了.</p><p>下面举一个实例</p><p>#当访问一个网页的时候,互联网协议是怎么运作的?<br>在浏览器地址栏输入google.com<br>意味着浏览器要向google服务器发送一个请求的数据包.当从本地请求一个网络地址的时候.</p><ul><li>第一步要走的是DNS的协议<br>我们知道发送数据包必须要知道对方的IP地址,但是我们现在只知道<a href="http://www.google.com.不知道他的IP地址" target="_blank" rel="noopener">www.google.com.不知道他的IP地址</a>.</li></ul><p>&emsp; &emsp;DNS协议就能够实现这样的功能,他可以将网址转换成IP地址<br>&emsp; &emsp;假设DNS服务器是8.8.8.8,于是向这个地址发送一个DNS数据包,使用53的端口.而DNS数据包的格式是这样的.<br>Ethernet head | IP head | UDP head | DNS data<br>–|–|–|–<br>&emsp; &emsp;我们发送这个数据包之后,DNS数据包会做出一个响应,他会告诉主机Google的IP地址.<br><br></p><ul><li>知道IP地址之后,就需要判断是否和本地处于同一个子网,就需要用到子网掩码.主机对本地的IP地址和从DNS服务器获取的IP地址进行二进制AND运算.由此判断是否在同一网络.</li></ul><p>&emsp; &emsp;因为不处于同一个子网,所以要向Google发送数据包就必须要经过网关(gateway).也就是路由器192.168.1.1. 进行转发.<br>接收方的MAC地址是网关的MAC地址.</p><ul><li>而浏览网页使用的是http协议,它的数据包结构是<br>Ethernet head | IP head | TCP head | http data<br>–|–|–|–<br>假设http请求数据包的长度是4960字节,它会被嵌在TCP的数据包当中.</li></ul><p>&emsp; &emsp;TCP协议<br>&emsp; &emsp;TCP的数据包需要设置一个端口,接收方(也就是google),他们的默认的http端口是80.<br>&emsp; &emsp;而发送方,也就是本机.它的端口是随机生成的1024-65535之间的整数.假设是12345.</p><p>&emsp; &emsp;TCP协议的标头(head)是20字节,加上嵌入http的数据包,总长度是4980字节.</p><ul><li>再往下走是IP协议,这是已知的,发送方是我本机,接受方IP地址是DNS响应包的里的地址.</li></ul><p>&emsp; &emsp;IP数据包的标头(head)是20字节,加上嵌入的TCP数据包,总长度是5000字节.</p><p>&emsp; &emsp;最后IP数据包嵌入以太网数据包,以太网数据包需要设置双方的MAC地址,发送方是本机的网卡MAC地址,接受方是网关的MAC地址.他通过ARP协议可以得到.</p><p>&emsp; &emsp;以太网的数据部分最大长度是1500字节,现在IP数据包的长度是5000字节,所以这个IP数据包要被分割成4个包.<br>因为每一个包都有自己的IP标头(head).他们是20个字节.</p><table><thead><tr><th>以太网包头</th><th>ip包头</th><th>tcp 数据</th></tr></thead><tbody><tr><td>Ethernet head</td><td>IP head</td><td>TCP data_1(1500字节)</td></tr><tr><td>Ethernet head</td><td>IP head</td><td>TCP data_2(1500字节)</td></tr><tr><td>Ethernet head</td><td>IP head</td><td>TCP data_3(1500字节)</td></tr><tr><td>Ethernet head</td><td>IP head</td><td>TCP data_4(560字节)</td></tr></tbody></table><p>&emsp; &emsp;这就是http的请求德过程,请求结束之后.服务端会给本机响应.传回HTML网页.浏览器将他渲染出来.</p><p>&emsp; &emsp;这个过程进过多个网关的转发.Google的服务器收到了四个数据包之后,根据IP标题的序号.把四个数据包拼起来,取出一个完整的TCP数据包.<br>&emsp; &emsp;然后去读取Http请求,接着做一个http响应.最后再用TCP协议发回来.<br>&emsp; &emsp;本机收到这个响应之后,我们就能看到这个网页,也就完成一次网络通讯.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应用层&lt;br&gt;&amp;emsp;&amp;emsp;由于互联网是开放的架构, 数据来源是五花八门.所以事先必须规定一些格式,否则根本没有办法解读.&lt;br&gt;&amp;emsp;&amp;emsp;现在讲的应用层就是规定应用程序的数据格式.&lt;br&gt;&amp;emsp;&amp;emsp;举个例子, TCP协议可以为各式各样的程序传递数据, 比如EMAIL,www,FTP等等, 那么必须有不同的协议规定电子邮件, 网页, FTP的数据格式.这些应用程序的协议就构成了一个应用层, 这就是我们说的五层协议里面最高的一层, 是面对用户的.&lt;/p&gt;
&lt;p&gt;他的数据就放在TCP协议的data部分,所以以太网数据包就会变成以下的样子.&lt;br&gt;Ethernet head | IP head |TCP head| –Application Layer data–&lt;br&gt;–|–|–|–|&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/46b9CAd.png&quot; alt=&quot;Imgur&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="网络通信协议" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络通信协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>网络通信(2)</title>
    <link href="http://yoursite.com/2018/11/07/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A12/"/>
    <id>http://yoursite.com/2018/11/07/网络通信2/</id>
    <published>2018-11-06T16:40:37.000Z</published>
    <updated>2018-11-09T04:11:37.456Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;之前说的是以太网协议,这里我们看网络层和传输层.<br>&emsp;&emsp;我们知道以太网是依靠MAC地址来发送数据的,理论上单单依靠MAC地址,上海的网卡就可以找到在北京的网卡,这在理论上是可以实现的.</p><p>&emsp;&emsp;但是它有一个严重的缺点,以太网采用广播的方式去发送一个数据包,如果每个程序员人手一个包的话,这样不仅效率低,而且发送者和接受者局限在子网当中.</p><p>&emsp;&emsp;也就是说,如果两个主机不在同一子网当中,广播是没有办法传输的.这种设计是比较合理的.否则互联网上每一台计算机都要收到这个包,这将是一场灾难.<br><a id="more"></a><br>&emsp;&emsp;互联网是由无数个子网组成的巨型网络.如果北京和上海在同一个子网络中,这几乎是不可能的.所以我们需要寻找以这个方法来区分哪些MAC地址是同一子网络的,哪些不是.<br>&emsp;&emsp;如果是同一子网的话,就使用广播的方式去发送数据,否则就选择路由的方式发送.<br>&emsp;&emsp;而路由的意思是如何向不同的子网分发数据包,这个是一个非常庞大的主题.我们这里不展开说.<br>&emsp;&emsp;非常遗憾的是MAC地址本身是不能做到这一点的,MAC地址只和厂商有关,和网络环境无关,这就导致了网络层的诞生.<br><br></p><p>#网络层<br>&emsp;&emsp;网络层的作用是引进了一套新的地址,让我们能够区分出不同的计算机是否处于同一个子网内.这一套地址就叫网络地址,简称网址.<br>&emsp;&emsp;网络层出现后,每一台计算机都有两个地址,一个是MAC地址,一个是网络地址.这两个地址是没有关系的.MAC地址是和网卡绑定的.而网络地址是由管理员分配的.他们只是随机的组合在一起.</p><p>&emsp;&emsp;网络地址帮助我们确定计算机所在的子网络.<br>&emsp;&emsp;MAC地址将我们的数据包发送到子网络中的目标网卡.<br>&emsp;&emsp;所以从逻辑上,我们判断是先处理网络地址,再处理MAC地址.</p><p> 由此引出IP协议,IP协议是指规定网络地址的额协议,他所定义的地址就是IP地址.目前广泛采用的是ipv4协议.这里不涉及ipv6的内容.<br>Ipv4是由32个二进制数组成的.我们习惯的把它分成4段的10进制数字.</p><blockquote><p>192.168.1.30<br>11000000- 10101000- 00000001- 00011110</p></blockquote><p>&emsp;&emsp;他的范围是0.0.0.0-255.255.255.255<br>&emsp;&emsp;在互联网上,每一台计算机都被分配一个IP地址,这个地址成两部分.<br>&emsp;&emsp;前三段(如 192.168.1)为一部分,代表网络<br>&emsp;&emsp;最后一段(如 30),代表主机,用这个30来确定这个主机<br>&emsp;&emsp;同一子网的计算机,他们的网络部分应该是一样的.</p><blockquote><p>192.168.1.1 和192.168.1.2<br>假设上面的IP地址的网络部分是前面的24位,也就是前三段,因为他们的网络部分相同,所以他们处于同一子网.</p></blockquote><p>&emsp;&emsp;但是有一个问题,单单从IP地址的话,我们是没有办法判断网络部分的.刚刚我们能判断,有一个前提.我们假定前三段是网络部分,但实际上,IP地址的网络部分到底是前面的24位还是16位,从IP地址本身是看不出来的.<br>那么如何从IP地址上判断两个计算机是不是处于同一子网.</p><p>&emsp;&emsp;这就引出了另外一个参数,子网掩码.所谓的子网掩码就是表示子网络特征的一个参数.它在形式上也是类似一个IP地址,同时也是一个32位的2进制数字,它的网络部分全是1,主机部分全是0.</p><blockquote><p>如 192.168.1.3<br>假设前面24位是网络部分,后面8位是主机部分.那么它的子网掩码就是255.255.255.0.<br>这个数字换算成2进制,前面24位都是1,后八位都是0.<br>当我们真的子网掩码之后,我们就可以判断任意的两个IP地址是否处于同一子网,方法是将这两个IP地址与子网掩码分别进行AND运算.然后比较他们的的结果是否一致.相同则表明在同一子网.反之,这不在.</p></blockquote><p>#总结<br>IP协议的主要作用是</p><ul><li>为每一台计算机分配一个IP地址</li><li>确定哪些地址再同一子网内</li></ul><p>IP数据包<br>head | ———data———<br>– | –<br>&emsp;&emsp;根据IP协议发送的数据包就叫做IP数据包,那其中必然包含了IP的地址信息<br>&emsp;&emsp;我们之前说过,以太网的数据包只包含一个MAC地址,并且没有IP地址的栏位,我们不需要修改数据包的定义,增加数据包的栏位.在说到以太网额那节课,我们说到:发送一个帧,帧里面有一个表头和数据.<br>&emsp;&emsp;实际上我们不必要去添加一个栏位去存储IP数据包.我们可以把IP的数据包直接放进以太网数据包中的data部分.所以不用修改以太网的规格.这就是互联网分层结构的好处.上层的变动完全不会下层的结构.<br>&emsp;&emsp;在程序开发的时候,也是一个道理.假设设计一个接口,用一个对象把参数封装起来.只要给对象添加一个内部属性,避免了一次次的添加参数.</p><p>&emsp;&emsp;具体到IP数据包,它也是有head和data两个部分,* head主要包含版本号,长度,IP地址这样的信息.</p><ul><li>data是IP数据包的具体内容.<br>IP数据包被放入以太网数据包内后,数据包就会变成</li></ul><table><thead><tr><th>Ethernet head</th><th>IP head</th><th>data</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>&emsp;&emsp;在这个结构中,IP head 在20-60字节之间 整个IP数据包长度为65535字节,所以理论上一个IP数据包的数据部分最长是65515.<br>我们前面提到,以太网的数据部分最长只有1500字节,所以ip数据包已经超过了1500字节,那么它就要分割成多个以太网数据包分开发送.</p><p>&emsp;&emsp;有一点值得一提,因为IP数据包是放在以太网数据包里发送的,所以我们必须同时知道两个地址.一个是对方的MAC地址,另一个是对方的IP地址.通常情况下,对方的IP地址是已知的,但是却不知道对方的MAC地址.</p><p>&emsp;&emsp;这个时候就涉及到ARP协议.我们假设存在两台计算机,这两台计算机就会分成两种情况.</p><ul><li><p>两台计算机不在同一子网 所以他没有办法知道对方的MAC地址,只能把数据包传输到两个子网连接的网关进行处理.</p></li><li><p>两台计算机在同一子网,这个时候就可以使用ARP协议,得到对方的IP地址.</p></li></ul><p>&emsp;&emsp;ARP协议也是发送一个数据包,这个包也是包含在以太网的数据包中,他包含了目标主机的IP地址,MAC地址.<br>&emsp;&emsp;他知道对方的IP地址,但是不知道地方的MAC地址,所以他零时用了6组16进制的数字去表示这是一个广播的地址,他所在子网的每一个主机都会收到这个数据包.<br>&emsp;&emsp;当这些主机收到这些数据包之后,他们把IP地址提取出来和自己的IP地址进行比较.如果都是相同的就做一个回复.告诉对方我就是你要找的目标主机,并且把自己的MAC地址上报上去.如果不相同则丢弃这个包.</p><p>&emsp;&emsp;总之,有了ARP协议之后,我们就有了同一子网内的主机的MAC地址,然后把数据包发送给任意一台主机.</p><p>&emsp;&emsp;我们有了MAC地址和IP地址,我们可以在两台主机上建立通信.现在的问题是同一台主机上有许多的程序都需要网络,比方说一边看网页,一边打开聊天软件.当一个数据包从互联网上发过来的时候,你怎么知道他是表示网页还是聊天内容.</p><p>&emsp;&emsp;也就是说,我们还需要一个参数,来表示数据包到底被哪一个进程使用.这个参数就叫端口(Port),他其实每一个使用网卡的进程的编号,每一个数据包都会发送到计算机的特定端口上.所以不同的进程就会获取到自己所需要的数据.</p><p>&emsp;&emsp;这个端口号是0-65535之间的整数.真好是16个2进制位.0-1023的端口被系统占用.所以我们在本地启动80或者443的时候会提示我们权限不够.用户一般只能选择在1023以上的端口.</p><p>&emsp;&emsp;不管是浏览网页还是在线聊天,程序都会随机选择一个端口与服务器的端口做一个联系.</p><p>#传输层<br>&emsp;&emsp;传输层的功能就是建立端口到端口之间的通讯.相比之下,网络层是建立主机到主机之间的通讯.只要确定了主机和端口,我们就可以实现程序和程序之间的交流.所以unix系统把主机加端口叫做套接字(Socket).有了他之后就可以进行网络编程了.</p><p>说到传输层不得不说,两个重要的协议<br>&emsp;&emsp;UDP和TCP<br>而他的格式几乎就是数据前面加上端口号<br>UDP的数据包也是由head和data组成.<br>head | <strong>_</strong>data_______<br>– | –<br>head部分定义 send port 和receive port<br>数据部分就是要发送的数据</p><p>然后把UDP数据包放到IP数据包的data部分<br>我们前面又说到IP数据包又是放在Ethernet协议的data部分<br>所以现在来看的话 Ethernet数据包变成现在这样<br>Ethernet head | IP head | UDP head | <strong>___</strong>UDP data_____<br>–|–|–|–|<br>&emsp;&emsp;UDP的head部分只有8个字节,总长度不会超过65535字节,刚好可以放进一个IP数据包.</p><p>&emsp;&emsp;这种协议的优点是简单,容易实现.但是缺点是可靠性差.数据包发送之后,不知道对方是不是已经收到了.为了解决这个问题,TCP协议应运而生.</p><p>&emsp;&emsp;TCP协议相对比较复杂,可以粗略的认为是有确认机制的UDP协议.每发送一次数据包都要进行确认.如果有一个数据包有遗失的话就收不到确认.那么发送的一方就知道,需要重新发送这个数据包.</p><p>&emsp;&emsp;关于TCP的三次握手,相对比较复杂.以后研究之后分享给大家<br><br><br>&emsp;&emsp;TCP的优点是内容不容易丢失,缺点是过程复杂,实现困难会消耗比较多的资源.<br>&emsp;&emsp;TCP数据包和UDP数据包一样都是内嵌在IP数据包中的.TCPd的数据包没有长度限制,理论上可以无线长的.但是为了保证网络的效率,TCP的数据包长度不会超过IP数据包的长度.这样会确保当个TCP的数据包不会再分割.</p><p>TCP</p><ul><li>面向连接</li><li>提供可靠资源</li><li>点对点 </li><li>资源消耗高<br>UDP</li><li>无连接  (在发送数据前不需要建立连接)</li><li>不保证可靠</li><li>实时性很强</li><li>一对一 ,多对一,多对多</li><li>资源消耗少</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;之前说的是以太网协议,这里我们看网络层和传输层.&lt;br&gt;&amp;emsp;&amp;emsp;我们知道以太网是依靠MAC地址来发送数据的,理论上单单依靠MAC地址,上海的网卡就可以找到在北京的网卡,这在理论上是可以实现的.&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;但是它有一个严重的缺点,以太网采用广播的方式去发送一个数据包,如果每个程序员人手一个包的话,这样不仅效率低,而且发送者和接受者局限在子网当中.&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;也就是说,如果两个主机不在同一子网当中,广播是没有办法传输的.这种设计是比较合理的.否则互联网上每一台计算机都要收到这个包,这将是一场灾难.&lt;br&gt;
    
    </summary>
    
      <category term="网络通信协议" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络通信协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>在Linux终端中写文件</title>
    <link href="http://yoursite.com/2018/10/26/linux%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C2/"/>
    <id>http://yoursite.com/2018/10/26/linux入门操作2/</id>
    <published>2018-10-26T04:55:01.000Z</published>
    <updated>2018-11-09T12:59:01.310Z</updated>
    
    <content type="html"><![CDATA[<p>在终端中写文件</p><p>sublime  text</p><p>vim 不要乱按键盘</p><p>新建   vim helloVIM.txt</p><p>在普通模式下 ,<br>输入冒号后,然后便可以输入字母并回车,来执行保存,退出<br>w:保存 q是退出<br><a id="more"></a><br>在普通模式下 按下 i 进入插入模式<br>esc按键是退出插入模式</p><p>上下左右键可以移动光标   没有上下左右键 hjkl</p><p>连续摁下两次D  即dd  删除行</p><p>shell文件<br>shell想要变成可执行文件的话  第一行一定是#!/bin/sh<br>先去一个名字 echo_ex.sh  后缀名一定是sh  代表是shell文件<br>代码:<br><code>#!/bin/sh</code><br><code>echo &quot;i am so smart&quot;</code><br><code>echo &quot;you are so smart too&quot;</code><br><code>echo &quot;i love you &quot;</code><br><code>echo &quot;i like your idea&quot;</code><br><code>echo &quot;i like studying and researching&quot;</code></p><p>然后退出并且保存</p><p>但是还是不能执行  信息需要把他变成可执行模式</p><p>sudo chmod 777 echo_ex.sh</p><p>然后再输入<code>./echo_ex.sh</code></p><p>编写shell 文件说法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在终端中写文件&lt;/p&gt;
&lt;p&gt;sublime  text&lt;/p&gt;
&lt;p&gt;vim 不要乱按键盘&lt;/p&gt;
&lt;p&gt;新建   vim helloVIM.txt&lt;/p&gt;
&lt;p&gt;在普通模式下 ,&lt;br&gt;输入冒号后,然后便可以输入字母并回车,来执行保存,退出&lt;br&gt;w:保存 q是退出&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>网络通讯协议(1)</title>
    <link href="http://yoursite.com/2018/10/25/TCP-IP-part1/"/>
    <id>http://yoursite.com/2018/10/25/TCP-IP-part1/</id>
    <published>2018-10-25T13:28:22.000Z</published>
    <updated>2018-11-06T16:13:51.337Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;互联网的实现分为好几层,每一层都有自己的功能,就好比盖房子,每一层都是依靠下一层的支持. 用户接触到的是最上面的一层.</p><p>&emsp;&emsp;用户接触到的是最上面的一层, 根本没有感觉到下面的层.而要理解互联网就必须要从下层开始, 自下而上的理解每一层的含义. 而如何分层,有不同的模型.</p><p>&emsp;&emsp;有的是七层模型, 有的分为五层. 我们一般倾向于五层协议, 这里给大家阐述的也都是五层协议.<br><br><br><img src="https://i.imgur.com/AYYE2WB.png" alt="GitHub Logo"><br><a id="more"></a><br>&emsp;&emsp;这个图中我们看见一个主机A和一主机B相互发送数据.而他们的底层支持就包含了这五层协议.</p><p><img src="https://i.imgur.com/OW22j94.png" alt="GitHub Logo"></p><p>自下而上</p><ul><li>Physcial Layer, 物理层 </li><li>Data Link Layer (MAC), 数据链路层 </li><li>Network Layer (IP), 网路层 </li><li>Transport Layer (TCP UDP), 传输层</li><li>Application Layer, 应用层</li></ul><p>&emsp;&emsp;越底层离物理硬件越近,越高层和用户越近.每一层都是完成某一种功能.<br>为了实现这些功能,需要遵守共同的规则,我们叫做协议(protocol)<br><br>&emsp;&emsp;在互联网中,每一层都定义了非常多的协议,而这些协议的总称就叫互联网协议,它是互联网的核心.</p><p><img src="https://i.imgur.com/tQWzvtg.png" alt="Imgur"></p><p>上图是对五层协议的概述:<br>&emsp;&emsp;应用层(Application Layer) : web服务器做交互<br>&emsp;&emsp;传输层(Transport Layer) : 两个远程主机建立连接<br>&emsp;&emsp;网路层(Network Layer) : 通过IP笛子传输数据包<br>&emsp;&emsp;数据链层(Data Link Layer) : 通过MAC地址交换帧数据<br>&emsp;&emsp;物理层(Physcial Layer) : 帧中的比特进行编码和解&emsp;&emsp;码，并包括在网络上驱动和接收信号的收发器。</p><p><img src="https://i.imgur.com/Vp3Cswb.jpg" alt="Imgur"></p><p>比方说 下载一个网页的话<br>&emsp;&emsp;应用层: 输一个IP地址192.168.1.102 默认输入80端口,下载他们<br>&emsp;&emsp;传输层: 它需要告诉服务器:客户端端口是31244,要连接的服务端端口是80<br>&emsp;&emsp;网路层: 两台主机的IP和端口在互相通讯<br>&emsp;&emsp;网络链路层: 添加包含MAC地址信息的标头以创建帧。然后将帧发送到物理层以发送比特</p><p>#物理层</p><p>&emsp;&emsp;电脑组网需要用电缆,光缆,无线电波把电脑连接起来.他们就是把电脑连接起来的物理手段.主要规定了网络中的电气特性,作用是负责传输0和1这样的电信号.</p><p>#数据链路<br>&emsp;&emsp;但是单纯的传输0和1,没有什么意义.所以,出现了数据链路层<br>&emsp;&emsp;多少个电信号算一组,一个信号位又有什么意义,数据链路层就解决了这个问题<br>&emsp;&emsp;他在物理层的上方确定了0和1的分组方式.也就是常说的以太网协议.<br>&emsp;&emsp;以太网协议规定一组电信号构成了一个数据包,我们把他叫做帧<br>&emsp;&emsp;每一个帧又分成两个部分,head 和 data<br>head|……..data………..<br>–|–<br>&emsp;&emsp;head:表头, 包含数据包的说明项 比方说发送者是谁,接受者是谁,数据类型等等<br>&emsp;&emsp;head在以太网协议中有一个长度的定义,他的固定长度是18个字节<br>&emsp;&emsp;data的长度最短是46字节,最长是1500字节<br>&emsp;&emsp;所以帧的最短长度是64字节,最长是1518字节<br>&emsp;&emsp;但是某些情况下,数据非常长,就需要被分割成多个帧进行发送</p><p>MAC地址:以太网的数据包的head包含了发送者和接受者的信息,MAC地址就是每一块网卡都有唯一的地址.长度是48个二进制位,通常是12个十六进制数去表示.有了这个MAC地址,就可以定位网卡和数据包的路径.为数据传输做了夯实的基础.</p><p>#广播<br>一个网卡为什么会知道另一块网卡的地址.这个时候在以太网中,有一个ARP协议,他可以解决这个问题.这个在后面会有所涉及.<br>我们需要知道,以太网数据包必须知道接收方的MAC地址才能够发送,<br>其次就算有了MAC地址,系统怎么样才能把数据包准确的发送到接受方.<br>在以太网中采用了一种非常原始的方式,他不是准确的把数据包发送到接受方<br>而是向本网络内的所有计算机房发送,让每一台计算机自己去判断自己是不是接受方.</p><p>假设1,2,3,4,5计算机在同一个网络中</p><ul><li>广播 1号计算机向处于同一网络中的所有计算机发送数据包</li><li>2,3,4,5号计算机都收到这个包,读取数据包head部分,找到接收方的MAC地址,与自身MAC地址比较</li><li>MAC地址相同的话就接受这个包,然后做进一步处理,否则丢弃这个包.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;互联网的实现分为好几层,每一层都有自己的功能,就好比盖房子,每一层都是依靠下一层的支持. 用户接触到的是最上面的一层.&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;用户接触到的是最上面的一层, 根本没有感觉到下面的层.而要理解互联网就必须要从下层开始, 自下而上的理解每一层的含义. 而如何分层,有不同的模型.&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;有的是七层模型, 有的分为五层. 我们一般倾向于五层协议, 这里给大家阐述的也都是五层协议.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/AYYE2WB.png&quot; alt=&quot;GitHub Logo&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="网络通信协议" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络通信协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>CURRENT AND VOLTAGE</title>
    <link href="http://yoursite.com/2018/10/15/Professional-English-1/"/>
    <id>http://yoursite.com/2018/10/15/Professional-English-1/</id>
    <published>2018-10-15T15:01:03.000Z</published>
    <updated>2018-10-20T03:48:25.524Z</updated>
    
    <content type="html"><![CDATA[<p>current n.电流</p><p>voltage n.电压</p><p>variable n.变量</p><p>charge n.电荷；v.充电，带电，起电</p><p>coulomb n.库仑（电荷的单位）</p><p>circuit n.电路<br><a id="more"></a></p><p>underlying a.①基本的，根本的②潜在的，下伏的</p><p>electron n.电子</p><p>positive charge 正电荷</p><p>negative charge 负电荷</p><p>magnitude n.大小，尺寸，数量，数值</p><p>electromotive a.电动的，起电的</p><p>electromotive force电动势</p><p>ampere n.安，安培（电流的单位）</p><p>integrate v.积分，求积分</p><p>work n.功</p><p>potential difference n.电位差</p><p>rectangular a.矩形的，直角的，正交的</p><p>joule n.焦尔（能量、热量、功的单位）</p><p>volt n.伏特（电压、电位、电势的单位)</p><p>voltaic battery 伏达电池</p><p>convention n.习惯，惯例，常规</p><p>reference direction 参考方向</p><p>polarity n.极性</p><p>power n.①功率，效率②动力，电力，能力，电源③乘方，幂</p><p>watt n.瓦特（功率的单位）</p><p>time-varying a.时变的</p><p>instantaneous power 瞬时功率</p><p>passive a.①无源的②消极的，被动的；</p><p>algebraic n.无源 a.代数的</p><p>instant n.瞬间，瞬时，即刻，时，时刻</p><hr><p>Current</p><p>current situation 现状，目前形势；现况</p><p>current status 当前状态；目前状况</p><p>current state 现行状态；初速电流状态</p><p>electric current 电流</p><p>direct current 直流；[电]直流电</p><p>alternating current (AC) 交流电</p><p>current density 电流密度；扩散（弥漫）流密度</p><p>eddy current 涡流；[电学]涡电流</p><p>tidal current 潮流</p><p>constant current 恒定电流</p><p>current transformer n. 电流变换器</p><p>leakage current [电]泄漏电流</p><p>high current 电流过高；高强度电流</p><p>current control 电流控制；日常检查</p><p>welding current 焊接电流</p><hr><p>voltage</p><p>low voltage 低电压</p><p>output voltage 输出电压</p><p>voltage stability 电压稳定；电压稳定度</p><p>input voltage 输入电压；工作电压</p><p>dc voltage 直流电压；直羚压</p><p>rated voltage [化]额定电压</p><p>voltage control 电压控制</p><p>voltage regulator 稳压器；调压器</p><p>voltage source n. 电压电源</p><p>supply voltage 电源电压；供给电压</p><p>voltage drop 电压降落</p><p>ac voltage 交流电压；交羚压</p><p>voltage transformer 电压互感器；电压变量器</p><p>constant voltage 恒定电压；定压</p><p>voltage regulation 稳压；电压调整；电压变动率</p><p>working voltage 工作电压；工诅压；操作电压</p><p>breakdown voltage [电]击穿电压</p><p>medium voltage 中压</p><p>applied voltage 外加电压</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;current n.电流&lt;/p&gt;
&lt;p&gt;voltage n.电压&lt;/p&gt;
&lt;p&gt;variable n.变量&lt;/p&gt;
&lt;p&gt;charge n.电荷；v.充电，带电，起电&lt;/p&gt;
&lt;p&gt;coulomb n.库仑（电荷的单位）&lt;/p&gt;
&lt;p&gt;circuit n.电路&lt;br&gt;
    
    </summary>
    
      <category term="English" scheme="http://yoursite.com/categories/English/"/>
    
    
      <category term="Electrical Professional English" scheme="http://yoursite.com/tags/Electrical-Professional-English/"/>
    
  </entry>
  
  <entry>
    <title>linux入门操作(1)</title>
    <link href="http://yoursite.com/2018/06/25/linux%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/06/25/linux入门操作/</id>
    <published>2018-06-25T04:45:28.000Z</published>
    <updated>2018-11-09T12:30:05.535Z</updated>
    
    <content type="html"><![CDATA[<p>使用环境:ubuntu 16.04 LTS</p><ul><li>终端<br>打开终端的方式有两种<br>直接寻找程序打开<br>使用快捷键 <code>ctrl +alt +T</code></li></ul><p>&emsp;&emsp;进入终端后,如果是默认设置的话,则会进入该用户的当前的家用户目录中<br>&emsp;&emsp;在终端中输入ls  就可以看到家目录下所有的内容<br>&emsp;&emsp;当输入<code>ls -l</code><br>&emsp;&emsp;就会显示当前目录下所有的内容的详细列表<br>&emsp;&emsp;这里的<code>-l</code> 是附加命令,是针对ls 这个命令进行的更多功能设置</p><p>当使用 ls 指令后我们看到 家目录下有一个downloads文件夹  我们进入这个文件夹,输入<code>cd downloads/</code></p><p>使用ls 指令会看到ls  至指令下 downloads 文件夹下有一个Ubuntu1.pdf </p><p>下面是几个基础知识,<br>首先linux的根目录是”/ “<br><a id="more"></a><br><code>cd /</code>  就可以进入到根目录<br>当前用户家目录则用~ 代替<br><code>cd ~</code>  就可以进入家目录文件夹</p><p>一般来说,以根目录”/“ 开始的路径 就被称为是绝对路径.<br>而当前用户的家目录的绝对路径则一般为<code>/home/用户名</code><br>使用<code>cd /home /用户名</code> 和使用<code>cd ~</code> 是一样的意思</p><p>使用tab 键可以自动补全需要的文件名 使用方法是输入文件夹名字的前几个字母,点击<code>TAB</code>键</p><p>双点代表上一级目录,单点代表当前目录<br><code>cd ..</code> 是返回上级目录<br><code>./</code>是当前科执行程序</p><p>新建文件夹 mkdir<br><code>mkdir  test</code><br><code>cd test/</code></p><p>删除文件夹 rmdir<br><code>rmdir 文件夹名</code><br>这个指令要求这个文件夹必须是空的才能删除</p><p>删除文件(夹) rm<br><code>rm 文件名</code>   删除文件<br><code>rm -rf</code>  文件夹名删除目标文件夹及其下的所有文件</p><p>在根目录下 mkdir  一般用户是不能使用的必须是root 用户才可以<br>使用<code>sudo mkdir</code>  才能实现新建</p><p>复制  cp<br>  源文件路径  目标路径<br><code>cp -rf 源文件路径 目标文件夹路径</code></p><p>移动 mv<br><code>mv  文件名 移动路径</code><br>mv不需要添加-rf命令</p><p>这个指令可以用来修改文件名<br>mv  文件名</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用环境:ubuntu 16.04 LTS&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;终端&lt;br&gt;打开终端的方式有两种&lt;br&gt;直接寻找程序打开&lt;br&gt;使用快捷键 &lt;code&gt;ctrl +alt +T&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;进入终端后,如果是默认设置的话,则会进入该用户的当前的家用户目录中&lt;br&gt;&amp;emsp;&amp;emsp;在终端中输入ls  就可以看到家目录下所有的内容&lt;br&gt;&amp;emsp;&amp;emsp;当输入&lt;code&gt;ls -l&lt;/code&gt;&lt;br&gt;&amp;emsp;&amp;emsp;就会显示当前目录下所有的内容的详细列表&lt;br&gt;&amp;emsp;&amp;emsp;这里的&lt;code&gt;-l&lt;/code&gt; 是附加命令,是针对ls 这个命令进行的更多功能设置&lt;/p&gt;
&lt;p&gt;当使用 ls 指令后我们看到 家目录下有一个downloads文件夹  我们进入这个文件夹,输入&lt;code&gt;cd downloads/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用ls 指令会看到ls  至指令下 downloads 文件夹下有一个Ubuntu1.pdf &lt;/p&gt;
&lt;p&gt;下面是几个基础知识,&lt;br&gt;首先linux的根目录是”/ “&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>无线充电</title>
    <link href="http://yoursite.com/2018/05/14/%E6%97%A0%E7%BA%BF%E5%85%85%E7%94%B5/"/>
    <id>http://yoursite.com/2018/05/14/无线充电/</id>
    <published>2018-05-14T02:46:50.000Z</published>
    <updated>2018-11-09T12:30:39.322Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/tHyaexi.png" alt="Imgur"><br>首先交流电经过电能发送端的整流电路和逆变电路变成高频的交流电，然后传递给线圈，将能量传送到电能的接收端，最后电能的接收端再经过整流或逆变得到直流电或交流电供给负载使用</p><p>#发射端<br><img src="https://i.imgur.com/qDB3Xck.png" alt="Imgur"><br>&emsp;&emsp;5V的直流电传递给给高频逆变电路，然后再传递给谐振网络，让系统频率变成 llOKHz至205KHz的高频交流电。高频率的交流电传递给后而的线圈，磁场会发生变化，手机系统能鼠的接收端线会感应到这种变化。反馈信号电路和控制器是对发射线圈电流的俭测.<br><a id="more"></a><br>&emsp;&emsp;当系统进行工作时，如果电流出现大的波动，表示系统正在进行不正常的充电或者系统遭到了破坏，那么反馈信号电路就会将信息传递给控制器，然后做出相应的调节，一方而保护了系统，另一方而也让系统能够更加精确.高效的工作。控制器接收反馈信号电路的信号，然后判断该系统足否能够正常工作.并对当前线圈的电流值进行相应计算。<br>频率的变化对系统非常重要，选择逆变电路的时候，要保证某一频率下，效率不会很低。从内部驱动的电路组成来看，大致可以分为全桥逆变电路。半桥逆变电路，单端式逆变电路。<br><img src="https://i.imgur.com/Pt9NRIz.png" alt="Imgur"><br>由上图可知，在全桥逆变的电路结构中4个开关管是一样的，通过控制这四 个管子的快速开通和关断来形成高频交流电，从而能够将电能传递给线圈的副边。<br>工作原理为：当Q1和Q4导通时，另外两个管子是关断的，电流经过Q1后流过 线圈，然后经过Q4流回电源负极；<br>同理，在下一时刻，Q2和Q3导通时，Q1和Q4是关断的，电流经过Q3后流过线圈，然后经Q2流回电源负极。其中二极管 作用为续流，这两个过程中流经线圈的电流方向相反，改变4个开关管的频率就可以改变交流线圈的电流频率.<br>本电路实现软开关变得控制比较容易。缺点是开关管的控制比较复杂。不过转换效率高，功率大。所以应用广泛。</p><p>#接收端<br><img src="https://i.imgur.com/op7EfSK.png" alt="Imgur"><br>AC- DC整流变换电路将手机接 端线圈中高频率的交流电转换成直流电 ，<br>此将转换成系统所需要的5 V直流电 ，然 后传递给负载 。反馈信号电路负<br>责 检 测 AC- DC变 换 电 路 的 输 出 电 值 ，并传送给控制器 ，然 后 让 控 制 器 能 够 及时的了解到当前传输功率的大小，这样可以及时的 将误差信息传递到发射端。在这里，控制器是很重要的组成部分，它能够监视用电设备的充电状态 ，比如充电 是否完成，充电是否异常等。 </p><p>前面分析得知，系统能量的输入端采用全桥逆变电路，然后经过耦合线圈将能量传递到输电到输出端。系统的主电路如下图所示。<br><img src="https://i.imgur.com/UjCLlBe.png" alt="Imgur"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/tHyaexi.png&quot; alt=&quot;Imgur&quot;&gt;&lt;br&gt;首先交流电经过电能发送端的整流电路和逆变电路变成高频的交流电，然后传递给线圈，将能量传送到电能的接收端，最后电能的接收端再经过整流或逆变得到直流电或交流电供给负载使用&lt;/p&gt;
&lt;p&gt;#发射端&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/qDB3Xck.png&quot; alt=&quot;Imgur&quot;&gt;&lt;br&gt;&amp;emsp;&amp;emsp;5V的直流电传递给给高频逆变电路，然后再传递给谐振网络，让系统频率变成 llOKHz至205KHz的高频交流电。高频率的交流电传递给后而的线圈，磁场会发生变化，手机系统能鼠的接收端线会感应到这种变化。反馈信号电路和控制器是对发射线圈电流的俭测.&lt;br&gt;
    
    </summary>
    
      <category term="电力电子" scheme="http://yoursite.com/categories/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90/"/>
    
    
      <category term="无线充电" scheme="http://yoursite.com/tags/%E6%97%A0%E7%BA%BF%E5%85%85%E7%94%B5/"/>
    
  </entry>
  
  <entry>
    <title>INTRO</title>
    <link href="http://yoursite.com/2018/05/13/INTRO/"/>
    <id>http://yoursite.com/2018/05/13/INTRO/</id>
    <published>2018-05-13T10:48:24.000Z</published>
    <updated>2018-11-09T12:28:42.637Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp; 业精于勤，荒于嬉；行成于思，毁于随</p><p>&nbsp; 共勉!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp; 业精于勤，荒于嬉；行成于思，毁于随&lt;/p&gt;
&lt;p&gt;&amp;nbsp; 共勉!&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="INTRO" scheme="http://yoursite.com/tags/INTRO/"/>
    
  </entry>
  
</feed>
