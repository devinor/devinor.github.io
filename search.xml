<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2019%2F07%2F13%2Fgit%2F</url>
    <content type="text"><![CDATA[#git clonegit clone 如果只想克隆某一个分支的时候比方说只想克隆dev分支git clone -b dev https://github.comm/repoweb #git tag项目开发了一个版本比方说V0.1git tag -a v0.1 -m ‘v0.1’ git tag 过滤选择自己想看的taggit tag -l ‘v0.0.*’ 想要把这次的tag推送到远程时git push –tag git tag 默认是打在最近的一次提交上如果想在某一次commit处加taggit tag -a v0.02 f573hb89a -m ‘v0.02’ #git statusgit 中 文件的状态类型有四种unstracked unmodified modified staged git status可以显示三种状态 已经添加到暂存区，待提交的 (git add 后) 已经修改 但是没有暂存的 未追踪的文件 #git diff 差异比较git diff比较所有文件差异 git diff [filename]默认比较workspace 和暂存(add)后的差别 也就是storged区 git diff –staged比较暂存区和上一次commit的差别 git diff HEAD [filename]比较指定版本 和 workspace #git commit git commit -m ‘commit message’提交信息最好遵从一定的规则我看到的一般是type(scope):subject type有以下几种常见的类型： feat:新功能 fix: 修复bug style: 格式 代码格式上的调整，不会影响到代码结构 refactor: 代码重构 比如if的嵌套太多，使用swith case 重写 chore: 项目上线，项目进行打包的时候，修改版本号的时候，最后一次提交记录 scope一般是自己负责的模块 subject具体的描述 e.g.git commit -m ‘fix(spi):修复读写的bug’ #git commond: git statusgit addgit commit 查看历史记录git log –pretty=onelinegit log –onelinegit relog 注意：git log –oneline 只能显示当前版本的之前版本 git版本回溯1.使用索引值（推荐）2.使用^符号(只能后退)3.使用~符号（只能后退） git reset –hard [索引值]e.g. git reset –hard cbeabd1 git reset –hard HEAD^e.g. git reset –hard HEAD^^ 回退比较多时git reset –hard HEAD~3 #git reset 三个参数回头看看git reset 命令本身 –soft仅仅在本地库中移动HEAD指针 –mixed在本地库中重置HEAD指针重置暂存区 –hard在本地库中移动HEAD指针重置暂存区重置工作区 –soft 只是移动了本地库 往前推一个版本，等于说撤销git commit（还有其他的理解，这种理解需要继续研究）–mixed 移动往前推一个版本，等于说撤销git add #删除文件 ##某一个文件被add,commit之后怎么删除工作区rm aaa.txt之后git status 提示:deleted aaa. txtgit add /rm aaa.txt 执行 git add aaa.txt 将删除的变化加入indexgit commit -m “deleted aaa.txt” git reflog 查看上一次commitgit reset –hard 还有一种情况 我们在工作区删除某个文件之后 只是git add 还有没有将删除操作commit到版本库中git reset –hard HEAD ##删除的文件并找回前提：删除前，文件存在时的状态有没有提交到本地库 #branch查看分支:git branch -v创建分支:git branch [分支名]切换分支:git checkout [分支名]创建分支并且跳转到分支中 git checkout -b [BranchName]分支删除：git branch -d [BranchName] ##合并分支 切换到接收修改的分支上 git checkout [需要被添加的内容] 执行merge git merge [有新内容的分支] ##冲突在同一文件的同一位置，两个分支都做了修改需要合并时，到底要听谁的 这就是冲突 编辑文件，删除特殊符号 把文件修改到满意的程度，保存退出 git add 文件名 git commit -m “日志“12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADggggggggggggg edit by hot-fix =======ggggggggggggg edit at master branch&gt;&gt;&gt;&gt;&gt;&gt;&gt; master #远程库的协作开发A 把本地库 push 远程库中B clone 远程库 到本地 使用 push 提交A 需要pull 把远程的代码变化下载到本地]]></content>
  </entry>
  <entry>
    <title><![CDATA[key_interrupt]]></title>
    <url>%2F2019%2F03%2F08%2Fkey-interrupt%2F</url>
    <content type="text"><![CDATA[#Exynos4412_key_driver.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;linux/module.h&gt; //linux 3.14/include/linux#include &lt;linux/kernel.h&gt; //define of printk#include &lt;linux/init.h&gt; //module_init module_exit#include &lt;linux/fs.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/device.h&gt; #include &lt;asm/io.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/interrupt.h&gt;struct timer_list key2_timer;struct timer_list key3_timer;extern int fs4412_led_on(int ledno);extern int fs4412_led_off(int ledno);void k2_timer_fn(unsigned long data)&#123; printk("k2_time_fn\n"); fs4412_led_on(2); fs4412_led_on(3); fs4412_led_off(4); fs4412_led_off(5);&#125;irqreturn_t key2_fn(int irqno,void *data)&#123; printk("key2 is pressed %d \n",irqno); printk("hello i am key2\n"); mod_timer(&amp;key2_timer, jiffies+500); return IRQ_HANDLED; &#125;void k3_timer_fn(unsigned long data)&#123; printk("k3_time_fn\n"); printk("\n\n\n\n"); fs4412_led_on(4); fs4412_led_on(5); fs4412_led_off(2); fs4412_led_off(3);&#125;irqreturn_t key3_fn(int irqno,void *data)&#123; printk("key3 is pressed %d \n",irqno); printk("hello i am key3\n"); mod_timer(&amp;key3_timer, jiffies+500); return IRQ_HANDLED; &#125;int fs4412_key_probe(struct platform_device *pdev) //在device定义的pdev&#123; int i = 0; for(;i &lt; pdev-&gt;num_resources; i++) &#123; printk("%p\n",pdev-&gt;resource[i].start); printk("%p\n",pdev-&gt;resource[i].end); printk("%p\n",pdev-&gt;resource[i].flags); &#125; //key2 register interrupt //IRQnumber //处理函数 //proc/interrupt里面 request_irq(pdev-&gt;resource[0].start,key2_fn,pdev-&gt;resource[0].flags,"key2",NULL); //key3 register interrupt request_irq(pdev-&gt;resource[1].start,key3_fn,pdev-&gt;resource[1].flags,"key3",NULL); key2_timer.function = k2_timer_fn; init_timer(&amp;key2_timer); key3_timer.function = k3_timer_fn; init_timer(&amp;key3_timer); return 0;&#125;int fs4412_key_remove(struct platform_device *pdev)&#123; printk("fs4412_key_remove\n"); free_irq(pdev-&gt;resource[0].start,NULL); free_irq(pdev-&gt;resource[1].start,NULL); return 0;&#125;int fs4412_key_suspend(struct platform_device *pdev,pm_message_t state)&#123; printk("fs4412_key_suspened\n"); return 0;&#125;int fs4412_key_resume(struct platform_device *pdev)&#123; printk("fs4412_key_resume\n"); return 0;&#125;struct of_device_id key_tbl[] = &#123; &#123; .compatible = "fs4412,key",&#125;, &#125;;struct platform_driver pdrv = &#123; .probe = fs4412_key_probe, .remove = fs4412_key_remove, .suspend = fs4412_key_suspend, .resume = fs4412_key_resume, .driver.name = "fs4412-key", .driver.of_match_table = key_tbl,&#125;;static int __init fs4412_key_driver_init(void)&#123; printk("fs4412_key_driver_init\n"); platform_driver_register(&amp;pdrv); return 0;&#125;static void __exit fs4412_key_driver_exit(void)&#123; printk("fs4412_key_driver_exit\n"); platform_driver_unregister(&amp;pdrv);&#125;MODULE_LICENSE("GPL");//许可声明 开源许可module_init(fs4412_key_driver_init);//声明入口module_exit(fs4412_key_driver_exit);//声明出口]]></content>
  </entry>
  <entry>
    <title><![CDATA[i2c_mpu6050]]></title>
    <url>%2F2019%2F03%2F07%2Fi2c-mpu6050%2F</url>
    <content type="text"><![CDATA[mpu6050.h123456789101112131415161718192021222324252627282930313233343536373839404142434445#ifndef MPU6050_HHHH#define MPU6050_HHHH#define MPU6050_MAGIC 'K'#define SMPLRT_DIV 0x19#define CONFIG 0x1A#define GYRO_CONFIG 0x1B#define ACCEL_CONFIG 0x1C#define ACCEL_XOUT_H 0x3B#define ACCEL_XOUT_L 0x3C#define ACCEL_YOUT_H 0x3D#define ACCEL_YOUT_L 0x3E#define ACCEL_ZOUT_H 0x3F#define ACCEL_ZOUT_L 0x40#define TEMP_OUT_H 0x41#define TEMP_OUT_L 0x42#define GYRO_XOUT_H 0x43#define GYRO_XOUT_L 0x44#define GYRO_YOUT_H 0x45#define GYRO_YOUT_L 0x46#define GYRO_ZOUT_H 0x47#define GYRO_ZOUT_L 0x48#define PWR_MGMT_1 0x6Bunion mpu6050_data&#123; struct &#123; unsigned short x; unsigned short y; unsigned short z; &#125;accel; struct &#123; unsigned short x; unsigned short y; unsigned short z; &#125;gyro; unsigned short temp;&#125;;#define GET_ACCEL _IOR(MPU6050_MAGIC, 0, union mpu6050_data)#define GET_GYRO _IOR(MPU6050_MAGIC, 1, union mpu6050_data) #define GET_TEMP _IOR(MPU6050_MAGIC, 2, union mpu6050_data)#endif i2c_driver.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215#include &lt;linux/module.h&gt; //linux 3.14/include/linux#include &lt;linux/kernel.h&gt; //define of printk#include &lt;linux/init.h&gt; //module_init module_exit#include &lt;linux/fs.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/device.h&gt; #include &lt;asm/io.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/uaccess.h&gt;#include "mpu6050.h"#include &lt;linux/i2c.h&gt;dev_t devno;unsigned int major;struct class *pcls;struct device *pdevice;static struct mpu6050_device&#123; struct i2c_client *client;&#125;;struct mpu6050_device *mpu6050;//这个函数为什么这样设计 函数的参数static int mpu6050_read_byte(struct i2c_client *client,unsigned char reg)&#123; char txbuf[1] = &#123;reg&#125;; char rxbuf[1]; struct i2c_msg msg[2] = &#123; &#123;client-&gt;addr,0,1,txbuf&#125;, &#123;client-&gt;addr,1,1,rxbuf&#125;, //读出来的数据放在rxbuf &#125;; i2c_transfer(client-&gt;adapter,msg,ARRAY_SIZE(msg)); return rxbuf[0];&#125;static int mpu6050_write_byte(struct i2c_client *client,unsigned char reg,unsigned char val )&#123; char txbuf[2] = &#123;reg,val&#125;; struct i2c_msg msg[1] = &#123; &#123;client-&gt;addr,0,2,txbuf&#125;, //mpu6050地址 写标志位 字节数 写的内容 &#125;; i2c_transfer(client-&gt;adapter, msg, ARRAY_SIZE(msg)); //adapter return 0;&#125;static int mpu6050_init(struct i2c_client *client)&#123; mpu6050_write_byte(client,PWR_MGMT_1,0x0); mpu6050_write_byte(client,SMPLRT_DIV,0x07); mpu6050_write_byte(client,CONFIG,0x06); mpu6050_write_byte(client,GYRO_CONFIG,0xf8); mpu6050_write_byte(client,ACCEL_CONFIG,0x19); printk("mpu6050 init success \n"); return 0;&#125;int mpu6050_open(struct inode *inode, struct file *file)&#123; return 0;&#125;void mpu6050_release(struct inode *inode, struct file *file)&#123; &#125;long mpu6050_ioctl(struct file *file, unsigned int cmd, unsigned long arg)&#123; union mpu6050_data data; struct i2c_client *client = mpu6050-&gt;client; switch(cmd) &#123; case GET_ACCEL: data.accel.x = mpu6050_read_byte(client,ACCEL_XOUT_L); data.accel.x |= mpu6050_read_byte(client,ACCEL_XOUT_H) &lt;&lt; 8; data.accel.y = mpu6050_read_byte(client,ACCEL_YOUT_L); data.accel.y |= mpu6050_read_byte(client,ACCEL_YOUT_H) &lt;&lt; 8; data.accel.z = mpu6050_read_byte(client,ACCEL_ZOUT_L); data.accel.z |= mpu6050_read_byte(client,ACCEL_ZOUT_H)&lt;&lt; 8; break; case GET_GYRO: data.gyro.x = mpu6050_read_byte(client,GYRO_XOUT_L); data.gyro.x |= mpu6050_read_byte(client,GYRO_XOUT_H)&lt;&lt;8; data.gyro.y = mpu6050_read_byte(client,GYRO_ZOUT_L); data.gyro.y |= mpu6050_read_byte(client,GYRO_ZOUT_H) &lt;&lt; 8; break; default: printk("invaild argument\n"); &#125; copy_to_user((void*)arg,&amp;data,sizeof(data)); return sizeof(data);&#125;static struct file_operations fops = &#123; .owner = THIS_MODULE, .open = mpu6050_open, .release = mpu6050_release, .unlocked_ioctl = mpu6050_ioctl,&#125;;static int mpu6050_probe(struct i2c_client * client, const struct device * id)&#123; printk("mpu6050_probe\n"); mpu6050 = kzalloc(sizeof(*mpu6050),GFP_KERNEL); mpu6050-&gt;client = client; major = register_chrdev(major,"mpu6050",&amp;fops); devno = MKDEV(major,0); printk("create the devno success\n"); pcls = class_create(THIS_MODULE,"mpu6050-auto"); pdevice = device_create(pcls,NULL,devno,NULL,"mpu6050"); printk("create the device node\n"); //hardware init mpu6050_init(client); printk("mpu6050_probe\n"); return 0;&#125;static int mpu6050_remove(struct i2c_client * client)&#123; printk("mpu6050 remove \n"); unregister_chrdev(major,"mpu6050"); device_destroy(pcls,devno); class_destroy(pcls); return 0;&#125;int mpu6050_suspend(struct i2c_client *client,pm_message_t state)&#123; printk("fs4412_i2c_suspened\n"); return 0;&#125;int mpu6050_resume(struct i2c_client *client)&#123; printk("fs4412_i2c_resume\n"); return 0;&#125;//一个是id_table 一个是.driver.of_match_table 都有什么用static const struct i2c_device_id mpu6050_id[] = &#123; &#123;"mpu6050",0&#125;,&#125;;static struct of_device_id mpu6050_dt_match[] = &#123; &#123;.compatible = "invense,mpu6050"&#125;,&#125;; //这里为什么需要结构体数组 只有一个设备啊 //结构体数组可以填多组 struct i2c_driver mpu6050_driver = &#123; .probe = mpu6050_probe, .remove = mpu6050_remove, .suspend = mpu6050_suspend, .resume = mpu6050_resume, .id_table = mpu6050_id, .driver = &#123; .name = "mpu6050", .owner = THIS_MODULE, .of_match_table = mpu6050_dt_match, &#125;,&#125;;static int __init fs4412_i2c_driver_init(void)&#123; printk("fs4412_i2c_driver_init\n"); //register i2c_add_driver(&amp;mpu6050_driver); return 0;&#125; static void __exit fs4412_i2c_driver_exit(void)&#123; printk("fs4412_i2c_driver_exit\n"); //unregister i2c_del_driver(&amp;mpu6050_driver); &#125;MODULE_LICENSE("GPL");//许可声明 开源许可module_init(fs4412_i2c_driver_init);//声明入口module_exit(fs4412_i2c_driver_exit);//声明出口 test_mpu6050123456789101112131415161718192021222324252627282930#include "stdio.h"#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include "mpu6050.h"int main()&#123; int fd; union mpu6050_data data; fd = open("/dev/mpu6050",O_RDWR); if(fd&lt;0) &#123; perror("open"); exit(1); &#125; while(1) &#123; ioctl(fd,GET_ACCEL,&amp;data); printf("acceleration data : x = %04x,y =%04x,z =%04x\n",data.accel.x,data.accel.y,data.accel.z); ioctl(fd,GET_GYRO,&amp;data); printf("gyroscope data: x = %04x,y =%04x,z =%04x\n",data.gyro.x,data.gyro.y,data.gyro.z); sleep(2); &#125; close(fd); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Exynos-4412-PWM-platform_driver]]></title>
    <url>%2F2019%2F03%2F05%2FExynos-4412-PWM-platform-driver%2F</url>
    <content type="text"><![CDATA[Exynos-4412平台的PWM驱动 使用的硬件资源： GPD0CON 0x114000a0 配置GPIO复用 TCFG0 0x139D_0000 配置预分频 TCFG1 0x139D_0004 配置分割器 二级分频 TCON 0x139D_0008 控制寄存器 TCNTB0 0x139D_000c 计数缓冲寄存器 TCMPB0 0x139D_0010 比较缓冲寄存器Exynos4412_beep_device.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/cdev.h&gt; #include &lt;linux/device.h&gt;#include &lt;asm/io.h&gt;#include &lt;linux/platform_device.h&gt;void Exynos4412_beep_release(struct device *dev)&#123; printk("Exynos4412 beep release\n");&#125;struct resource beep_res[] =&#123; [0] = &#123; .start = 0x114000a0, .end = 0x11000c40 + 0x3, .flags = IORESOURCE_MEM, &#125;, [1] = &#123; .start = 0x139d0000, .end = 0x139d0000 + 0x13, .flags = IORESOURCE_MEM, &#125;,&#125;;struct platform_device pdev =&#123; .name = "Exynos4412-beep", .id = -1, .dev.release = Exynos4412_beep_release, .num_resources = ARRAY_SIZE(beep_res), .resource =beep_res,&#125;;static int __init Exynos4412_beep_device_init(void)&#123; printk("Exynos4412_beep_device_init\n"); platform_device_register(&amp;pdev);&#125;static int __exit Exynos4412_beep_device_exit(void)&#123; printk("Exynos4412_beep_device_exit\n"); platform_device_unregister(&amp;pdev);&#125;MODULE_LICENSE("GPL");module_init(Exynos4412_beep_device_init); module_exit(Exynos4412_beep_device_exit); Exynos4412_beep_driver.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;linux/module.h&gt; //linux 3.14/include/linux#include &lt;linux/kernel.h&gt; //printk #include &lt;linux/init.h&gt; //module_init module_exit#include &lt;linux/fs.h&gt; //struct file_operations#include &lt;linux/cdev.h&gt; //struct cdev#include &lt;linux/device.h&gt;#include &lt;asm/io.h&gt;#include &lt;linux/platform_device.h&gt;dev_t devno; //�豸��unsigned int major;struct class *pcls; struct device *pdevice; //这个结构体是用来生成设备节点的#define TCFG0 0x0#define TCFG1 0x04#define TCON 0x8#define TCNTB0 0xc#define TCMPB0 0x10void *pgpd0con;void *ptimer0base;int Exynos4412_beep_ioremap(struct platform_device *pdev)&#123; pgpd0con = ioremap(pdev-&gt;resource[0].start,pdev-&gt;resource[0].end-pdev-&gt;resource[0].start+1); ptimer0base = ioremap(pdev-&gt;resource[1].start,pdev-&gt;resource[1].end-pdev-&gt;resource[1].start+1); return 0;&#125;int Exynos4412_beep_on(void)&#123; writel((readl(ptimer0base+TCON)&amp;(~(0xf&lt;&lt;0)))|(0x9&lt;&lt;0),ptimer0base+TCON); return 0;&#125;int Exynos4412_beep_off(void)&#123; writel((readl(ptimer0base+TCON)&amp;(~(0x1&lt;&lt;0))),ptimer0base+TCON); return 0;&#125;#define HZ_BEEP 10000void Exynos4412_beep_setfre(int fre)&#123; writel(HZ_BEEP/fre,ptimer0base+TCNTB0); writel(HZ_BEEP/(fre*2),ptimer0base+TCMPB0);&#125;int Exynos4412_beep_init(void)&#123; writel((readl(pgpd0con)&amp;(~(0xf&lt;&lt;0)))|(0x2&lt;&lt;0),pgpd0con); writel((readl(ptimer0base+TCFG0)&amp;(~(0xff&lt;&lt;0)))|(0xff&lt;&lt;0),ptimer0base+TCFG0); writel((readl(ptimer0base+TCFG1)&amp;(~(0xf&lt;&lt;0)))|(0x1&lt;&lt;0),ptimer0base+TCFG1); writel(1000,ptimer0base+TCNTB0); writel(500,ptimer0base+TCMPB0); writel((readl(ptimer0base+TCON)&amp;(~(0xf&lt;&lt;0)))|(0x2&lt;&lt;0),ptimer0base+TCON); return 0;&#125;int Exynos4412_beep_open(struct inode* inode,struct file* file)&#123; printk("Exynos4412_beep_open\n"); Exynos4412_beep_on(); return 0;&#125;int Exynos4412_beep_release(struct inode* inode,struct file* file)&#123; printk("fs4412_beep_close\n"); Exynos4412_beep_off(); return 0;&#125;#define MAGIC_NUM 'k'#define BEEP_ON _IO(MAGIC_NUM,0)#define BEEP_OFF _IO(MAGIC_NUM,1)#define BEEP_FRE _IO(MAGIC_NUM,2)long Exynos4412_beep_ioctl(struct file* file,unsigned int cmd, unsigned long arg)&#123; switch(cmd) &#123; case BEEP_ON: Exynos4412_beep_on(); break; case BEEP_OFF: Exynos4412_beep_off(); break; case BEEP_FRE: Exynos4412_beep_setfre(arg); break; &#125; return 0;&#125;struct file_operations fops = &#123; //ϵͳ���÷��� .open = Exynos4412_beep_open, .release = Exynos4412_beep_release, .unlocked_ioctl = Exynos4412_beep_ioctl,&#125;;int Exynos4412_beep_probe(struct platform_device *pdev)&#123; int i = 0; printk("Exynos4412_beep_probe\n"); for(;i&lt;pdev-&gt;num_resources;i++) &#123; printk("%p\n",pdev-&gt;resource[i].start); printk("%p\n",pdev-&gt;resource[i].end); printk("%x\n",pdev-&gt;resource[i].flags); &#125; //1�����ַ��豸 major = register_chrdev(major,"Exynos4412-beep",&amp;fops); devno = MKDEV(major,0); //2�Զ������豸�ڵ� pcls = class_create(THIS_MODULE,"beep-auto"); pdevice = device_create(pcls,NULL,devno,NULL,"Exynos4412-beep"); //Ӳ����ʼ�� Exynos4412_beep_ioremap(pdev); Exynos4412_beep_init(); return 0;&#125;int Exynos4412_beep_remove(struct platform_device *pdev)&#123; printk("Exynos4412_beep_remove\n"); unregister_chrdev(major,"Exynos4412-beep"); device_destroy(pcls,devno); class_destroy(pcls); return 0;&#125;int Exynos4412_beep_suspend(struct platform_device *pdev,pm_message_t state)&#123; printk("Exynos4412_beep_suspend\n"); return 0;&#125;int Exynos4412_beep_resume(struct platform_device *pdev)&#123; printk("Exynos4412_beep_resume\n"); return 0;&#125;struct platform_driver pdrv =&#123; .probe = Exynos4412_beep_probe, .remove = Exynos4412_beep_remove, .suspend = Exynos4412_beep_suspend, .resume = Exynos4412_beep_resume, .driver.name = "Exynos4412-beep"&#125;;// �ں���ʱ�����insmodʱ������static int __init hello_init(void) //���ӱ�־����Ѻ�������init��&#123; printk("Exynos4412-beep driver init\n"); platform_driver_register(&amp;pdrv); return 0;&#125;// �ں˹ػ�����rmmodʱ�����static void __exit hello_exit(void)&#123; printk("exit Exynos4412 beep device\n"); platform_driver_unregister(&amp;pdrv);&#125;MODULE_LICENSE("GPL");//�������module_init(hello_init); //�������module_exit(hello_exit);]]></content>
  </entry>
  <entry>
    <title><![CDATA[虚拟内存技术]]></title>
    <url>%2F2019%2F02%2F26%2F%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[###虚拟内存技术操作系统的虚拟内存管理机制起来什么作用？ #####第一&emsp;可以控制物理内存的访问权限。 &emsp;&emsp;物理内存本身是不限制访问的，任何地址理论上来说都是可以读写的，而操作系统要求不同的页面具有不同的访问权限，这是利用CPU模式和MMU内存保护机制实现的。&emsp;&emsp;例如Test Segment被只读保护起来，防止执行了错误的指令意外改写了Test Segment，内核地址空间也被保护起来，防止在用户模式下访问内核数据或执行内核代码。&emsp;这样错误的指令或者是恶意的代码的破坏能力受到了限制，顶多使当前进程因为段错误而终止，不会影响整个系统的稳定性。 #####第二&emsp;可以让每一个进程都有独立的地址空间。&emsp;&emsp;不同的进程中相同的VA(virtul address)被MMU映射到不同的PA(physical adress)。所以在每一个进程中访问任何虚拟地址都是不可能访问到属于另一个进程的物理内存的页面。并且每一个进程都认为自己独占了0x0000 0000 - 0xbfff ffff 的整个用户地址空间。 &emsp;&emsp;独占的好处就是，任何进程执行了错误指令或者是恶意的代码导致的非法内存访问都不会意外改写其他进程的数据，也不会影响其他进程的运行。 &emsp;&emsp;打开一个终端，查看终端进程的地址空间 $ cat /proc/2668/maps 1234567891011121314151617181920212223242526272829303132333435363738394008048000-08124000 r-xp 00000000 08:01 262149 /bin/bash08124000-08125000 r--p 000db000 08:01 262149 /bin/bash08125000-0812a000 rw-p 000dc000 08:01 262149 /bin/bash0812a000-0812f000 rw-p 00000000 00:00 0 09e01000-0a091000 rw-p 00000000 00:00 0 [heap]b715f000-b717e000 r--p 00000000 08:01 1192977 /usr/share/locale-langpack/zh_CN/LC_MESSAGES/bash.mob717e000-b7189000 r-xp 00000000 08:01 1442771 /lib/i386-linux-gnu/libnss_files-2.15.sob7189000-b718a000 r--p 0000a000 08:01 1442771 /lib/i386-linux-gnu/libnss_files-2.15.sob718a000-b718b000 rw-p 0000b000 08:01 1442771 /lib/i386-linux-gnu/libnss_files-2.15.sob718b000-b71a1000 r-xp 00000000 08:01 1442765 /lib/i386-linux-gnu/libnsl-2.15.sob71a1000-b71a2000 r--p 00015000 08:01 1442765 /lib/i386-linux-gnu/libnsl-2.15.sob71a2000-b71a3000 rw-p 00016000 08:01 1442765 /lib/i386-linux-gnu/libnsl-2.15.sob71a3000-b71a5000 rw-p 00000000 00:00 0 b71a5000-b71ac000 r-xp 00000000 08:01 1442767 /lib/i386-linux-gnu/libnss_compat-2.15.sob71ac000-b71ad000 r--p 00006000 08:01 1442767 /lib/i386-linux-gnu/libnss_compat-2.15.sob71ad000-b71ae000 rw-p 00007000 08:01 1442767 /lib/i386-linux-gnu/libnss_compat-2.15.sob71c1000-b7365000 r--p 03f51000 08:01 534160 /usr/lib/locale/locale-archiveb7365000-b7565000 r--p 00000000 08:01 534160 /usr/lib/locale/locale-archiveb7565000-b7566000 rw-p 00000000 00:00 0 b7566000-b7705000 r-xp 00000000 08:01 1442720 /lib/i386-linux-gnu/libc-2.15.sob7705000-b7707000 r--p 0019f000 08:01 1442720 /lib/i386-linux-gnu/libc-2.15.sob7707000-b7708000 rw-p 001a1000 08:01 1442720 /lib/i386-linux-gnu/libc-2.15.sob7708000-b770c000 rw-p 00000000 00:00 0 b770c000-b770f000 r-xp 00000000 08:01 1442733 /lib/i386-linux-gnu/libdl-2.15.sob770f000-b7710000 r--p 00002000 08:01 1442733 /lib/i386-linux-gnu/libdl-2.15.sob7710000-b7711000 rw-p 00003000 08:01 1442733 /lib/i386-linux-gnu/libdl-2.15.sob7711000-b772d000 r-xp 00000000 08:01 1442817 /lib/i386-linux-gnu/libtinfo.so.5.9b772d000-b772f000 r--p 0001b000 08:01 1442817 /lib/i386-linux-gnu/libtinfo.so.5.9b772f000-b7730000 rw-p 0001d000 08:01 1442817 /lib/i386-linux-gnu/libtinfo.so.5.9b7730000-b7737000 r--s 00000000 08:01 531129 /usr/lib/i386-linux-gnu/gconv/gconv-modules.cacheb7737000-b7741000 r-xp 00000000 08:01 1442775 /lib/i386-linux-gnu/libnss_nis-2.15.sob7741000-b7742000 r--p 00009000 08:01 1442775 /lib/i386-linux-gnu/libnss_nis-2.15.sob7742000-b7743000 rw-p 0000a000 08:01 1442775 /lib/i386-linux-gnu/libnss_nis-2.15.sob7743000-b7745000 rw-p 00000000 00:00 0 b7745000-b7746000 r-xp 00000000 00:00 0 [vdso]b7746000-b7766000 r-xp 00000000 08:01 1442700 /lib/i386-linux-gnu/ld-2.15.sob7766000-b7767000 r--p 0001f000 08:01 1442700 /lib/i386-linux-gnu/ld-2.15.sob7767000-b7768000 rw-p 00020000 08:01 1442700 /lib/i386-linux-gnu/ld-2.15.sobff9d000-bffbe000 rw-p 00000000 00:00 0 [stack] #####第三 &emsp;VA到PA的映射会给分配和释放内存带来便利&emsp;&emsp;物理地址不连续的几块内存空间也可以映射成虚拟地址连续的一块内存。比如malloc会分配一块很大的内存空间，虽然有足够多的空闲物理内存，但是却没有足够大的连续空闲内存，这个时候就可以分配多个不连续的物理页面而映射到连续的虚拟地址范围。 #####第四&emsp;&emsp;一个系统如果同时运行很多进程，为进程分配的内存之和可能会大于实际可用的物理内存，虚拟内存管理机制使这种情况下各种进程仍然能够正常运行。进程访问的是虚拟内存页面，这些页面数据可以保存在物理页面中，也可以零时保存在磁盘上而不占用页面的数据。&emsp;&emsp;可以在磁盘上开辟一个分区或者文件专门用于临时保存虚拟内存页面的数据，叫做交换设备（Swap Device)。启动了交换设备之后，系统可以分配内存总量是 物理内存和交换设备的大小之和。 &emsp;&emsp;当物理内存不够的时候，操作系统将不常用的物理页面中的数据临时保存到交换设备。解除VA到PA的映射，这个物理页面就可以认为是空闲的。也可以重新分配给进程使用，这个过程称为Page out.]]></content>
      <tags>
        <tag>linux virtual memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos系统文件]]></title>
    <url>%2F2018%2F11%2F21%2F%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[bin 文件夹 储存的是二进制目录 用户集工具boot文件夹 启动目录dev 文件夹 设备文件夹 创建设备节点etc文件夹 是系统的配置的文件目录 壁纸 logohome文件夹 用户文件夹lib文件夹 库目录 是系统和应用层序的库文件media文件夹 是媒体目录 存放可移动媒体设备的挂载点 光盘mnt 文件夹 挂载目录 是可移动设备 u盘opt 文件夹 可选目录 第三方的软件包 或者是下载的内容proc文件夹 进程文件夹root文件夹 根目录run文件夹 运行目录 比如说是本地服务的运行文件sbin文件夹 存放的是二进制文件srv文件夹 服务目录 存放本地服务的相关文件sys 文件夹 系统目录 存放硬件信息tmp文件夹 临时文件夹usr 文件夹 用户的二进制文件夹 用户的文件和数据都是存放在这里var 文件夹 是可变化目录 一般用来存放日志文件]]></content>
  </entry>
  <entry>
    <title><![CDATA[ros系统catkin文件]]></title>
    <url>%2F2018%2F11%2F07%2Fros%E7%B3%BB%E7%BB%9Fcatkin%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[catkin 是用来编译ros程序的catkin 工作空间就是一个文件夹组织和管理功能包的文件用catkin工具编译 各种ros代码放在catkin workpace 文件夹中如何:创建一个catkin的文件空间指令:catkin_make 帮助我们初始化工作空间$mkdir ~p ~/catkin_ws/src$cd ~/catkin_ws/$catkin_make其实catkin_make的主要功能是编译 编译$cd -/catkin_ws #回到工作空间$catkin_make$source -/catkin_ws/devel/setup.bash #编译完成之后要source刷新环境 注意:catkin_make 之前一定要回到catkin workspacecatkin_make 之后一定要devel/setup.bash这句话是把刚刚编译的worksapce 刷新到环境里面 catkin workspace 里的src文件 package源代码 build文件夹 cmake&amp; catkin 缓存文件和中间文件devel文件夹: 生成的目标文件 包括 1.头文件 2.动态链接库 3.静态链接库 4.可执行文件bulid 和devel 初学者不用掌握 注意::ros build 是旧的版本 看到资料直接忽略 src里面到底有什么src 里面有许多packagepackage 是catkin编译的基本单元catkin的编译对象就是一个又一个package]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络通信协议(3)]]></title>
    <url>%2F2018%2F11%2F07%2F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE3%2F</url>
    <content type="text"><![CDATA[应用层&emsp;&emsp;由于互联网是开放的架构, 数据来源是五花八门.所以事先必须规定一些格式,否则根本没有办法解读.&emsp;&emsp;现在讲的应用层就是规定应用程序的数据格式.&emsp;&emsp;举个例子, TCP协议可以为各式各样的程序传递数据, 比如EMAIL,www,FTP等等, 那么必须有不同的协议规定电子邮件, 网页, FTP的数据格式.这些应用程序的协议就构成了一个应用层, 这就是我们说的五层协议里面最高的一层, 是面对用户的. 他的数据就放在TCP协议的data部分,所以以太网数据包就会变成以下的样子.Ethernet head | IP head |TCP head| –Application Layer data––|–|–|–|&emsp;&emsp; 在这幅图中, 有4台主机.1和2处于一个子网,3和4处于同一子网.&emsp; &emsp; 如果1给4发送数据包.然后4告诉1, 收到了数据包.这样就可以实现两台计算机之间的通讯.&emsp; &emsp; 而发送这个数据包就必须需要两个地址. MAC地址和IP地址, 有了这两个地址之后, 数据包才能够准确的送到接受者的手中.&emsp; &emsp; 但是MAC地址是有局限的, 如果两台主机不在同一子网, 就没有办法知道彼此的MAC地址. &emsp;&emsp; 所以出现了网关(gateway), 它实现转发的功能. 主机1给主机4发送数据包.他先判断主机4是否处于同一子网.如果不是, 主机1把数据包发给他的网关(A).&emsp; &emsp; 这网关通过路由协议, 发现了主机4处于另一个网关内(B). A网关把数据发送给了B网关, B网关又把数据转发给了主机4. &emsp; &emsp; 主机1想要把数据发送给A网关, 需要知道A网关的MAC地址.&emsp; &emsp; 所以数据包的目标地址实际上分为两种情况.场景|数据包地址–|–目标主机同一子网|对方的MAC地址,对方的IP地址目标主机非同一子网|网关的MAC地址,对方的IP地址 我们在windows中连接网络,可能会看到静态IP和动态IP的选项 我们给电脑插上网线开机之后,不能立刻上网.我们必须要给电脑 设置本机IP 设置子网掩码 设置网关的IP地址 设置DNS的IP地址 静态IP&emsp; 首先它设置比较专业&emsp; 其次设置静态IP后这个IP不能被其他计算机使用处于这两点, 大部分用户都是使用动态IP地址上网. 动态IP&emsp; 所谓的动态IP就是指计算机开机以后会自动分配一个ip地址, 这个IP地址不会被别人设定. 动态IP使用的协议是DHCP协议 &emsp;&emsp; 这个协议规定了,在每一个子网中, 有一台计算机作为DHCP服务器.它专门去负责这个网络内的所有IP地址的自动分配.&emsp; &emsp; 所有新的计算机加入这个网络之后,必须向DHCP服务器发送一个DHCP请求数据包.以此来申请IP地址和相关的网络参数. &emsp; &emsp; 之前提到,两个主机在同一子网时,必须知道对方的MAC地址IP地址,才能发送数据包. &emsp; &emsp;但是问题来了新加入的主机不知道这两个地址. DHCP协议做了一些比较巧妙的设定,首先它是应用层的协议,建立在UDP协议之上.所以数据包是这样的 Ethernet head IP head UDP head DHCP data &emsp; &emsp; 最前面的Ethernet head设置发出方,比如本机的MAC地和接受方DHCP服务器的MAC地址. &emsp; &emsp; 发射方的MAC地址就是本机网卡的MAC地址,DHCP服务器的MAC地址是不知道的. &emsp; &emsp; 这个时候就会填入广播的地址,有一个默认的6组16进制数组成. FF:FF:FF:FF:FF:FF &emsp; &emsp; 后面的IP head 设置了发出方的IP地址和接受方的IP地址.对于两个主机而言,他们本机都不知道.于是发出方的IP设为0.0.0.0,接收方的IP设为255.255.255.255. &emsp; &emsp; 最后的UDP head设置发出方的端口和接受方的端口.这部分是由DHCP协议规定好的,发出方是68端口,接受方式67端口. &emsp; &emsp; 数据包构造完成之后就可以发送了.以太网是以广播发送的,在同一子网内的每一台主机都会收到这个包.因为接收方的地址是FF:FF:FF:FF:FF:FF所以看不出来是发给谁的.收到这个包的主机会分析这个包的IP地址,确定是不是发给自己的.之前讲ARP协议的时候,已经有接触. &emsp; &emsp; 当看到发出方的IP地址是0.0.0.0,接收方IP地址是255.255.255.255.于是DHCP服务器就知道这个包是发给我的.其他主机就会丢弃这个包. &emsp; &emsp; 接下来DHCP服务器会读出这个包的数据内容,然后分配好一个IP地址,发送回去一个DHCP响应数据包. &emsp; &emsp; DHCP响应数据包.它的格式和DHCP数据包类似.分配给请求方的IP地址和其他网络参数都会包含在data这部分.新加入的主机就知道了自己的IP地址,子网掩码,网关地址. 有了这个之后就可以上网冲浪了. 下面举一个实例 #当访问一个网页的时候,互联网协议是怎么运作的?在浏览器地址栏输入google.com意味着浏览器要向google服务器发送一个请求的数据包.当从本地请求一个网络地址的时候. 第一步要走的是DNS的协议我们知道发送数据包必须要知道对方的IP地址,但是我们现在只知道www.google.com.不知道他的IP地址. &emsp; &emsp;DNS协议就能够实现这样的功能,他可以将网址转换成IP地址&emsp; &emsp;假设DNS服务器是8.8.8.8,于是向这个地址发送一个DNS数据包,使用53的端口.而DNS数据包的格式是这样的.Ethernet head | IP head | UDP head | DNS data–|–|–|–&emsp; &emsp;我们发送这个数据包之后,DNS数据包会做出一个响应,他会告诉主机Google的IP地址. 知道IP地址之后,就需要判断是否和本地处于同一个子网,就需要用到子网掩码.主机对本地的IP地址和从DNS服务器获取的IP地址进行二进制AND运算.由此判断是否在同一网络. &emsp; &emsp;因为不处于同一个子网,所以要向Google发送数据包就必须要经过网关(gateway).也就是路由器192.168.1.1. 进行转发.接收方的MAC地址是网关的MAC地址. 而浏览网页使用的是http协议,它的数据包结构是Ethernet head | IP head | TCP head | http data–|–|–|–假设http请求数据包的长度是4960字节,它会被嵌在TCP的数据包当中. &emsp; &emsp;TCP协议&emsp; &emsp;TCP的数据包需要设置一个端口,接收方(也就是google),他们的默认的http端口是80.&emsp; &emsp;而发送方,也就是本机.它的端口是随机生成的1024-65535之间的整数.假设是12345. &emsp; &emsp;TCP协议的标头(head)是20字节,加上嵌入http的数据包,总长度是4980字节. 再往下走是IP协议,这是已知的,发送方是我本机,接受方IP地址是DNS响应包的里的地址. &emsp; &emsp;IP数据包的标头(head)是20字节,加上嵌入的TCP数据包,总长度是5000字节. &emsp; &emsp;最后IP数据包嵌入以太网数据包,以太网数据包需要设置双方的MAC地址,发送方是本机的网卡MAC地址,接受方是网关的MAC地址.他通过ARP协议可以得到. &emsp; &emsp;以太网的数据部分最大长度是1500字节,现在IP数据包的长度是5000字节,所以这个IP数据包要被分割成4个包.因为每一个包都有自己的IP标头(head).他们是20个字节. 以太网包头 ip包头 tcp 数据 Ethernet head IP head TCP data_1(1500字节) Ethernet head IP head TCP data_2(1500字节) Ethernet head IP head TCP data_3(1500字节) Ethernet head IP head TCP data_4(560字节) &emsp; &emsp;这就是http的请求德过程,请求结束之后.服务端会给本机响应.传回HTML网页.浏览器将他渲染出来. &emsp; &emsp;这个过程进过多个网关的转发.Google的服务器收到了四个数据包之后,根据IP标题的序号.把四个数据包拼起来,取出一个完整的TCP数据包.&emsp; &emsp;然后去读取Http请求,接着做一个http响应.最后再用TCP协议发回来.&emsp; &emsp;本机收到这个响应之后,我们就能看到这个网页,也就完成一次网络通讯.]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>网络通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络通信(2)]]></title>
    <url>%2F2018%2F11%2F07%2F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A12%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前说的是以太网协议,这里我们看网络层和传输层.&emsp;&emsp;我们知道以太网是依靠MAC地址来发送数据的,理论上单单依靠MAC地址,上海的网卡就可以找到在北京的网卡,这在理论上是可以实现的. &emsp;&emsp;但是它有一个严重的缺点,以太网采用广播的方式去发送一个数据包,如果每个程序员人手一个包的话,这样不仅效率低,而且发送者和接受者局限在子网当中. &emsp;&emsp;也就是说,如果两个主机不在同一子网当中,广播是没有办法传输的.这种设计是比较合理的.否则互联网上每一台计算机都要收到这个包,这将是一场灾难.&emsp;&emsp;互联网是由无数个子网组成的巨型网络.如果北京和上海在同一个子网络中,这几乎是不可能的.所以我们需要寻找以这个方法来区分哪些MAC地址是同一子网络的,哪些不是.&emsp;&emsp;如果是同一子网的话,就使用广播的方式去发送数据,否则就选择路由的方式发送.&emsp;&emsp;而路由的意思是如何向不同的子网分发数据包,这个是一个非常庞大的主题.我们这里不展开说.&emsp;&emsp;非常遗憾的是MAC地址本身是不能做到这一点的,MAC地址只和厂商有关,和网络环境无关,这就导致了网络层的诞生. #网络层&emsp;&emsp;网络层的作用是引进了一套新的地址,让我们能够区分出不同的计算机是否处于同一个子网内.这一套地址就叫网络地址,简称网址.&emsp;&emsp;网络层出现后,每一台计算机都有两个地址,一个是MAC地址,一个是网络地址.这两个地址是没有关系的.MAC地址是和网卡绑定的.而网络地址是由管理员分配的.他们只是随机的组合在一起. &emsp;&emsp;网络地址帮助我们确定计算机所在的子网络.&emsp;&emsp;MAC地址将我们的数据包发送到子网络中的目标网卡.&emsp;&emsp;所以从逻辑上,我们判断是先处理网络地址,再处理MAC地址. 由此引出IP协议,IP协议是指规定网络地址的额协议,他所定义的地址就是IP地址.目前广泛采用的是ipv4协议.这里不涉及ipv6的内容.Ipv4是由32个二进制数组成的.我们习惯的把它分成4段的10进制数字. 192.168.1.3011000000- 10101000- 00000001- 00011110 &emsp;&emsp;他的范围是0.0.0.0-255.255.255.255&emsp;&emsp;在互联网上,每一台计算机都被分配一个IP地址,这个地址成两部分.&emsp;&emsp;前三段(如 192.168.1)为一部分,代表网络&emsp;&emsp;最后一段(如 30),代表主机,用这个30来确定这个主机&emsp;&emsp;同一子网的计算机,他们的网络部分应该是一样的. 192.168.1.1 和192.168.1.2假设上面的IP地址的网络部分是前面的24位,也就是前三段,因为他们的网络部分相同,所以他们处于同一子网. &emsp;&emsp;但是有一个问题,单单从IP地址的话,我们是没有办法判断网络部分的.刚刚我们能判断,有一个前提.我们假定前三段是网络部分,但实际上,IP地址的网络部分到底是前面的24位还是16位,从IP地址本身是看不出来的.那么如何从IP地址上判断两个计算机是不是处于同一子网. &emsp;&emsp;这就引出了另外一个参数,子网掩码.所谓的子网掩码就是表示子网络特征的一个参数.它在形式上也是类似一个IP地址,同时也是一个32位的2进制数字,它的网络部分全是1,主机部分全是0. 如 192.168.1.3假设前面24位是网络部分,后面8位是主机部分.那么它的子网掩码就是255.255.255.0.这个数字换算成2进制,前面24位都是1,后八位都是0.当我们真的子网掩码之后,我们就可以判断任意的两个IP地址是否处于同一子网,方法是将这两个IP地址与子网掩码分别进行AND运算.然后比较他们的的结果是否一致.相同则表明在同一子网.反之,这不在. #总结IP协议的主要作用是 为每一台计算机分配一个IP地址 确定哪些地址再同一子网内 IP数据包head | ———data———– | –&emsp;&emsp;根据IP协议发送的数据包就叫做IP数据包,那其中必然包含了IP的地址信息&emsp;&emsp;我们之前说过,以太网的数据包只包含一个MAC地址,并且没有IP地址的栏位,我们不需要修改数据包的定义,增加数据包的栏位.在说到以太网额那节课,我们说到:发送一个帧,帧里面有一个表头和数据.&emsp;&emsp;实际上我们不必要去添加一个栏位去存储IP数据包.我们可以把IP的数据包直接放进以太网数据包中的data部分.所以不用修改以太网的规格.这就是互联网分层结构的好处.上层的变动完全不会下层的结构.&emsp;&emsp;在程序开发的时候,也是一个道理.假设设计一个接口,用一个对象把参数封装起来.只要给对象添加一个内部属性,避免了一次次的添加参数. &emsp;&emsp;具体到IP数据包,它也是有head和data两个部分,* head主要包含版本号,长度,IP地址这样的信息. data是IP数据包的具体内容.IP数据包被放入以太网数据包内后,数据包就会变成 Ethernet head IP head data &emsp;&emsp;在这个结构中,IP head 在20-60字节之间 整个IP数据包长度为65535字节,所以理论上一个IP数据包的数据部分最长是65515.我们前面提到,以太网的数据部分最长只有1500字节,所以ip数据包已经超过了1500字节,那么它就要分割成多个以太网数据包分开发送. &emsp;&emsp;有一点值得一提,因为IP数据包是放在以太网数据包里发送的,所以我们必须同时知道两个地址.一个是对方的MAC地址,另一个是对方的IP地址.通常情况下,对方的IP地址是已知的,但是却不知道对方的MAC地址. &emsp;&emsp;这个时候就涉及到ARP协议.我们假设存在两台计算机,这两台计算机就会分成两种情况. 两台计算机不在同一子网 所以他没有办法知道对方的MAC地址,只能把数据包传输到两个子网连接的网关进行处理. 两台计算机在同一子网,这个时候就可以使用ARP协议,得到对方的IP地址. &emsp;&emsp;ARP协议也是发送一个数据包,这个包也是包含在以太网的数据包中,他包含了目标主机的IP地址,MAC地址.&emsp;&emsp;他知道对方的IP地址,但是不知道地方的MAC地址,所以他零时用了6组16进制的数字去表示这是一个广播的地址,他所在子网的每一个主机都会收到这个数据包.&emsp;&emsp;当这些主机收到这些数据包之后,他们把IP地址提取出来和自己的IP地址进行比较.如果都是相同的就做一个回复.告诉对方我就是你要找的目标主机,并且把自己的MAC地址上报上去.如果不相同则丢弃这个包. &emsp;&emsp;总之,有了ARP协议之后,我们就有了同一子网内的主机的MAC地址,然后把数据包发送给任意一台主机. &emsp;&emsp;我们有了MAC地址和IP地址,我们可以在两台主机上建立通信.现在的问题是同一台主机上有许多的程序都需要网络,比方说一边看网页,一边打开聊天软件.当一个数据包从互联网上发过来的时候,你怎么知道他是表示网页还是聊天内容. &emsp;&emsp;也就是说,我们还需要一个参数,来表示数据包到底被哪一个进程使用.这个参数就叫端口(Port),他其实每一个使用网卡的进程的编号,每一个数据包都会发送到计算机的特定端口上.所以不同的进程就会获取到自己所需要的数据. &emsp;&emsp;这个端口号是0-65535之间的整数.真好是16个2进制位.0-1023的端口被系统占用.所以我们在本地启动80或者443的时候会提示我们权限不够.用户一般只能选择在1023以上的端口. &emsp;&emsp;不管是浏览网页还是在线聊天,程序都会随机选择一个端口与服务器的端口做一个联系. #传输层&emsp;&emsp;传输层的功能就是建立端口到端口之间的通讯.相比之下,网络层是建立主机到主机之间的通讯.只要确定了主机和端口,我们就可以实现程序和程序之间的交流.所以unix系统把主机加端口叫做套接字(Socket).有了他之后就可以进行网络编程了. 说到传输层不得不说,两个重要的协议&emsp;&emsp;UDP和TCP而他的格式几乎就是数据前面加上端口号UDP的数据包也是由head和data组成.head | _data_______– | –head部分定义 send port 和receive port数据部分就是要发送的数据 然后把UDP数据包放到IP数据包的data部分我们前面又说到IP数据包又是放在Ethernet协议的data部分所以现在来看的话 Ethernet数据包变成现在这样Ethernet head | IP head | UDP head | ___UDP data_____–|–|–|–|&emsp;&emsp;UDP的head部分只有8个字节,总长度不会超过65535字节,刚好可以放进一个IP数据包. &emsp;&emsp;这种协议的优点是简单,容易实现.但是缺点是可靠性差.数据包发送之后,不知道对方是不是已经收到了.为了解决这个问题,TCP协议应运而生. &emsp;&emsp;TCP协议相对比较复杂,可以粗略的认为是有确认机制的UDP协议.每发送一次数据包都要进行确认.如果有一个数据包有遗失的话就收不到确认.那么发送的一方就知道,需要重新发送这个数据包. &emsp;&emsp;关于TCP的三次握手,相对比较复杂.以后研究之后分享给大家&emsp;&emsp;TCP的优点是内容不容易丢失,缺点是过程复杂,实现困难会消耗比较多的资源.&emsp;&emsp;TCP数据包和UDP数据包一样都是内嵌在IP数据包中的.TCPd的数据包没有长度限制,理论上可以无线长的.但是为了保证网络的效率,TCP的数据包长度不会超过IP数据包的长度.这样会确保当个TCP的数据包不会再分割. TCP 面向连接 提供可靠资源 点对点 资源消耗高UDP 无连接 (在发送数据前不需要建立连接) 不保证可靠 实时性很强 一对一 ,多对一,多对多 资源消耗少]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>网络通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux终端中写文件]]></title>
    <url>%2F2018%2F10%2F26%2Flinux%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C2%2F</url>
    <content type="text"><![CDATA[在终端中写文件 sublime text vim 不要乱按键盘 新建 vim helloVIM.txt 在普通模式下 ,输入冒号后,然后便可以输入字母并回车,来执行保存,退出w:保存 q是退出在普通模式下 按下 i 进入插入模式esc按键是退出插入模式 上下左右键可以移动光标 没有上下左右键 hjkl 连续摁下两次D 即dd 删除行 shell文件shell想要变成可执行文件的话 第一行一定是#!/bin/sh先去一个名字 echo_ex.sh 后缀名一定是sh 代表是shell文件代码:#!/bin/shecho &quot;i am so smart&quot;echo &quot;you are so smart too&quot;echo &quot;i love you &quot;echo &quot;i like your idea&quot;echo &quot;i like studying and researching&quot; 然后退出并且保存 但是还是不能执行 信息需要把他变成可执行模式 sudo chmod 777 echo_ex.sh 然后再输入./echo_ex.sh 编写shell 文件说法]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络通讯协议(1)]]></title>
    <url>%2F2018%2F10%2F25%2FTCP-IP-part1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;互联网的实现分为好几层,每一层都有自己的功能,就好比盖房子,每一层都是依靠下一层的支持. 用户接触到的是最上面的一层. &emsp;&emsp;用户接触到的是最上面的一层, 根本没有感觉到下面的层.而要理解互联网就必须要从下层开始, 自下而上的理解每一层的含义. 而如何分层,有不同的模型. &emsp;&emsp;有的是七层模型, 有的分为五层. 我们一般倾向于五层协议, 这里给大家阐述的也都是五层协议.&emsp;&emsp;这个图中我们看见一个主机A和一主机B相互发送数据.而他们的底层支持就包含了这五层协议. 自下而上 Physcial Layer, 物理层 Data Link Layer (MAC), 数据链路层 Network Layer (IP), 网路层 Transport Layer (TCP UDP), 传输层 Application Layer, 应用层 &emsp;&emsp;越底层离物理硬件越近,越高层和用户越近.每一层都是完成某一种功能.为了实现这些功能,需要遵守共同的规则,我们叫做协议(protocol)&emsp;&emsp;在互联网中,每一层都定义了非常多的协议,而这些协议的总称就叫互联网协议,它是互联网的核心. 上图是对五层协议的概述:&emsp;&emsp;应用层(Application Layer) : web服务器做交互&emsp;&emsp;传输层(Transport Layer) : 两个远程主机建立连接&emsp;&emsp;网路层(Network Layer) : 通过IP笛子传输数据包&emsp;&emsp;数据链层(Data Link Layer) : 通过MAC地址交换帧数据&emsp;&emsp;物理层(Physcial Layer) : 帧中的比特进行编码和解&emsp;&emsp;码，并包括在网络上驱动和接收信号的收发器。 比方说 下载一个网页的话&emsp;&emsp;应用层: 输一个IP地址192.168.1.102 默认输入80端口,下载他们&emsp;&emsp;传输层: 它需要告诉服务器:客户端端口是31244,要连接的服务端端口是80&emsp;&emsp;网路层: 两台主机的IP和端口在互相通讯&emsp;&emsp;网络链路层: 添加包含MAC地址信息的标头以创建帧。然后将帧发送到物理层以发送比特 #物理层 &emsp;&emsp;电脑组网需要用电缆,光缆,无线电波把电脑连接起来.他们就是把电脑连接起来的物理手段.主要规定了网络中的电气特性,作用是负责传输0和1这样的电信号. #数据链路&emsp;&emsp;但是单纯的传输0和1,没有什么意义.所以,出现了数据链路层&emsp;&emsp;多少个电信号算一组,一个信号位又有什么意义,数据链路层就解决了这个问题&emsp;&emsp;他在物理层的上方确定了0和1的分组方式.也就是常说的以太网协议.&emsp;&emsp;以太网协议规定一组电信号构成了一个数据包,我们把他叫做帧&emsp;&emsp;每一个帧又分成两个部分,head 和 datahead|……..data………..–|–&emsp;&emsp;head:表头, 包含数据包的说明项 比方说发送者是谁,接受者是谁,数据类型等等&emsp;&emsp;head在以太网协议中有一个长度的定义,他的固定长度是18个字节&emsp;&emsp;data的长度最短是46字节,最长是1500字节&emsp;&emsp;所以帧的最短长度是64字节,最长是1518字节&emsp;&emsp;但是某些情况下,数据非常长,就需要被分割成多个帧进行发送 MAC地址:以太网的数据包的head包含了发送者和接受者的信息,MAC地址就是每一块网卡都有唯一的地址.长度是48个二进制位,通常是12个十六进制数去表示.有了这个MAC地址,就可以定位网卡和数据包的路径.为数据传输做了夯实的基础. #广播一个网卡为什么会知道另一块网卡的地址.这个时候在以太网中,有一个ARP协议,他可以解决这个问题.这个在后面会有所涉及.我们需要知道,以太网数据包必须知道接收方的MAC地址才能够发送,其次就算有了MAC地址,系统怎么样才能把数据包准确的发送到接受方.在以太网中采用了一种非常原始的方式,他不是准确的把数据包发送到接受方而是向本网络内的所有计算机房发送,让每一台计算机自己去判断自己是不是接受方. 假设1,2,3,4,5计算机在同一个网络中 广播 1号计算机向处于同一网络中的所有计算机发送数据包 2,3,4,5号计算机都收到这个包,读取数据包head部分,找到接收方的MAC地址,与自身MAC地址比较 MAC地址相同的话就接受这个包,然后做进一步处理,否则丢弃这个包.]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>网络通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CURRENT AND VOLTAGE]]></title>
    <url>%2F2018%2F10%2F15%2FProfessional-English-1%2F</url>
    <content type="text"><![CDATA[current n.电流 voltage n.电压 variable n.变量 charge n.电荷；v.充电，带电，起电 coulomb n.库仑（电荷的单位） circuit n.电路 underlying a.①基本的，根本的②潜在的，下伏的 electron n.电子 positive charge 正电荷 negative charge 负电荷 magnitude n.大小，尺寸，数量，数值 electromotive a.电动的，起电的 electromotive force电动势 ampere n.安，安培（电流的单位） integrate v.积分，求积分 work n.功 potential difference n.电位差 rectangular a.矩形的，直角的，正交的 joule n.焦尔（能量、热量、功的单位） volt n.伏特（电压、电位、电势的单位) voltaic battery 伏达电池 convention n.习惯，惯例，常规 reference direction 参考方向 polarity n.极性 power n.①功率，效率②动力，电力，能力，电源③乘方，幂 watt n.瓦特（功率的单位） time-varying a.时变的 instantaneous power 瞬时功率 passive a.①无源的②消极的，被动的； algebraic n.无源 a.代数的 instant n.瞬间，瞬时，即刻，时，时刻 Current current situation 现状，目前形势；现况 current status 当前状态；目前状况 current state 现行状态；初速电流状态 electric current 电流 direct current 直流；[电]直流电 alternating current (AC) 交流电 current density 电流密度；扩散（弥漫）流密度 eddy current 涡流；[电学]涡电流 tidal current 潮流 constant current 恒定电流 current transformer n. 电流变换器 leakage current [电]泄漏电流 high current 电流过高；高强度电流 current control 电流控制；日常检查 welding current 焊接电流 voltage low voltage 低电压 output voltage 输出电压 voltage stability 电压稳定；电压稳定度 input voltage 输入电压；工作电压 dc voltage 直流电压；直羚压 rated voltage [化]额定电压 voltage control 电压控制 voltage regulator 稳压器；调压器 voltage source n. 电压电源 supply voltage 电源电压；供给电压 voltage drop 电压降落 ac voltage 交流电压；交羚压 voltage transformer 电压互感器；电压变量器 constant voltage 恒定电压；定压 voltage regulation 稳压；电压调整；电压变动率 working voltage 工作电压；工诅压；操作电压 breakdown voltage [电]击穿电压 medium voltage 中压 applied voltage 外加电压]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>Electrical Professional English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux C编程 一站式学习]]></title>
    <url>%2F2018%2F09%2F10%2F%E5%B5%8C%E5%85%A5%E5%BC%8FC%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;《linux C编程 一站式学习》&emsp;&emsp;再学一次C语言。&emsp;&emsp;从大学一年纪学习C语言。一直都是在windows平台下。 &emsp;&emsp;windows不用自己配置，所有操作都是界面化，win10之后连防火墙都不必要安装。 &emsp;&emsp;都是微软给惯坏了，哪怕我们日常随手接触的电脑，还是不了解系统底层的操作。对于普通的消费者而言，这没有什么，因为他们并不需要了解系统底层到底是怎么运作的，也不需要了解数据到底是怎么从一台电脑发送到另一台电脑的。&emsp;&emsp;但是对于需要对计算机和互联网有更加深入理解的朋友。学习好使用Linux会对我们有很大的提升。刚好之前购置了一台VPS主机，一直用作是V2ray的服务器了。最近给安装了Debian系统。ssh连接一下就可以愉快的做linux练习机了。 &emsp;&emsp;这就是我最近购置的关于linux下C语言的编程书籍。也可以看作是重新再学一次C语言了。&emsp;]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux入门操作(1)]]></title>
    <url>%2F2018%2F06%2F25%2Flinux%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[使用环境:ubuntu 16.04 LTS 终端打开终端的方式有两种直接寻找程序打开使用快捷键 ctrl +alt +T &emsp;&emsp;进入终端后,如果是默认设置的话,则会进入该用户的当前的家用户目录中&emsp;&emsp;在终端中输入ls 就可以看到家目录下所有的内容&emsp;&emsp;当输入ls -l&emsp;&emsp;就会显示当前目录下所有的内容的详细列表&emsp;&emsp;这里的-l 是附加命令,是针对ls 这个命令进行的更多功能设置 当使用 ls 指令后我们看到 家目录下有一个downloads文件夹 我们进入这个文件夹,输入cd downloads/ 使用ls 指令会看到ls 至指令下 downloads 文件夹下有一个Ubuntu1.pdf 下面是几个基础知识,首先linux的根目录是”/ “cd / 就可以进入到根目录当前用户家目录则用~ 代替cd ~ 就可以进入家目录文件夹 一般来说,以根目录”/“ 开始的路径 就被称为是绝对路径.而当前用户的家目录的绝对路径则一般为/home/用户名使用cd /home /用户名 和使用cd ~ 是一样的意思 使用tab 键可以自动补全需要的文件名 使用方法是输入文件夹名字的前几个字母,点击TAB键 双点代表上一级目录,单点代表当前目录cd .. 是返回上级目录./是当前科执行程序 新建文件夹 mkdirmkdir testcd test/ 删除文件夹 rmdirrmdir 文件夹名这个指令要求这个文件夹必须是空的才能删除 删除文件(夹) rmrm 文件名 删除文件rm -rf 文件夹名删除目标文件夹及其下的所有文件 在根目录下 mkdir 一般用户是不能使用的必须是root 用户才可以使用sudo mkdir 才能实现新建 复制 cp 源文件路径 目标路径cp -rf 源文件路径 目标文件夹路径 移动 mvmv 文件名 移动路径mv不需要添加-rf命令 这个指令可以用来修改文件名mv 文件名]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无线充电]]></title>
    <url>%2F2018%2F05%2F14%2F%E6%97%A0%E7%BA%BF%E5%85%85%E7%94%B5%2F</url>
    <content type="text"><![CDATA[首先交流电经过电能发送端的整流电路和逆变电路变成高频的交流电，然后传递给线圈，将能量传送到电能的接收端，最后电能的接收端再经过整流或逆变得到直流电或交流电供给负载使用 #发射端&emsp;&emsp;5V的直流电传递给给高频逆变电路，然后再传递给谐振网络，让系统频率变成 llOKHz至205KHz的高频交流电。高频率的交流电传递给后而的线圈，磁场会发生变化，手机系统能鼠的接收端线会感应到这种变化。反馈信号电路和控制器是对发射线圈电流的俭测.&emsp;&emsp;当系统进行工作时，如果电流出现大的波动，表示系统正在进行不正常的充电或者系统遭到了破坏，那么反馈信号电路就会将信息传递给控制器，然后做出相应的调节，一方而保护了系统，另一方而也让系统能够更加精确.高效的工作。控制器接收反馈信号电路的信号，然后判断该系统足否能够正常工作.并对当前线圈的电流值进行相应计算。频率的变化对系统非常重要，选择逆变电路的时候，要保证某一频率下，效率不会很低。从内部驱动的电路组成来看，大致可以分为全桥逆变电路。半桥逆变电路，单端式逆变电路。由上图可知，在全桥逆变的电路结构中4个开关管是一样的，通过控制这四 个管子的快速开通和关断来形成高频交流电，从而能够将电能传递给线圈的副边。工作原理为：当Q1和Q4导通时，另外两个管子是关断的，电流经过Q1后流过 线圈，然后经过Q4流回电源负极；同理，在下一时刻，Q2和Q3导通时，Q1和Q4是关断的，电流经过Q3后流过线圈，然后经Q2流回电源负极。其中二极管 作用为续流，这两个过程中流经线圈的电流方向相反，改变4个开关管的频率就可以改变交流线圈的电流频率.本电路实现软开关变得控制比较容易。缺点是开关管的控制比较复杂。不过转换效率高，功率大。所以应用广泛。 #接收端AC- DC整流变换电路将手机接 端线圈中高频率的交流电转换成直流电 ，此将转换成系统所需要的5 V直流电 ，然 后传递给负载 。反馈信号电路负责 检 测 AC- DC变 换 电 路 的 输 出 电 值 ，并传送给控制器 ，然 后 让 控 制 器 能 够 及时的了解到当前传输功率的大小，这样可以及时的 将误差信息传递到发射端。在这里，控制器是很重要的组成部分，它能够监视用电设备的充电状态 ，比如充电 是否完成，充电是否异常等。 前面分析得知，系统能量的输入端采用全桥逆变电路，然后经过耦合线圈将能量传递到输电到输出端。系统的主电路如下图所示。]]></content>
      <categories>
        <category>电力电子</category>
      </categories>
      <tags>
        <tag>无线充电</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[INTRO]]></title>
    <url>%2F2018%2F05%2F13%2FINTRO%2F</url>
    <content type="text"><![CDATA[&nbsp; 业精于勤，荒于嬉；行成于思，毁于随 &nbsp; 共勉!]]></content>
      <tags>
        <tag>INTRO</tag>
      </tags>
  </entry>
</search>
